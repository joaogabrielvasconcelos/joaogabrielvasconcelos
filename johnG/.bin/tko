#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations


from typing import List, Dict, Tuple, Optional, Any, Callable, Union, Set
import os
import shutil
import subprocess
import argparse
import sys
import urllib.request
import urllib.error
import json
import curses
import random
import enum
import urllib
import tempfile
import datetime
import webbrowser
import re
import math
import configparser
from subprocess import PIPE
import unicodedata
__version__ = "0.22.7"


def get_default_settings_for_borders() -> bool:
    if os.name == "nt":
        return False
    return True

class AppSettings:
    __rootdir = "rootdir"
    __is_ascii = "ascii"
    __is_color = "color"
    __diffmode = "diffmode"
    __sidesize = "sidesize"
    __langdef = "langdef"
    __lastrep = "lastrep"
    __nerdfonts = "nerdfonts"
    __editor = "editor"
    __timeout = "timeout"

    defaults = {
        __rootdir: "",
        __is_ascii: False,
        __is_color: True,
        __diffmode: "side",
        __sidesize: 80,
        __langdef: "",
        __lastrep: "", 
        __nerdfonts: get_default_settings_for_borders(),
        __editor: "code",
        __timeout: 1
    }

    def __init__(self):
        self.data: Dict[str, Any] = {}
        for key in AppSettings.defaults:
            self.data[key] = AppSettings.defaults[key]

    def __set(self, key: str, value: Any):
        self.data[key] = value
        return self

    def __get(self, key: str) -> Any:
        if key not in self.defaults:
            raise ValueError(f"Key {key} not found in AppSettings")
        if key not in self.data:
            self.data[key] = AppSettings.defaults[key]
        return self.data[key]


    def get_timeout(self) -> int:
        return self.__get(self.__timeout)
    
    def set_timeout(self, value: int):
        self.__set(self.__timeout, value)
        return self

    def get_editor(self) -> str:
        return self.__get(self.__editor)
    
    def set_editor(self, value: str):
        self.__set(self.__editor, value)
        return self

    def get_last_rep(self) -> str:
        return self.__get(self.__lastrep)
    
    def set_last_rep(self, value: str):
        self.__set(self.__lastrep, value)
        return self

    def to_dict(self) -> Dict[str, Any]:
        return self.data

    def from_dict(self, data: Dict[str, Any]):
        self.data = data
        return self

    def __str__(self) -> str:
        return str(self.data)


    def get_rootdir(self) -> str:
        value = self.__get(self.__rootdir)
        return value
    
    def is_nerdfonts(self) -> bool:
        return self.__get(self.__nerdfonts)
    
    def set_nerdfonts(self, value: bool):
        self.__set(self.__nerdfonts, value)
        return self

    def set_rootdir(self, value: str):
        self.__set(self.__rootdir, value)
        return self

    def is_ascii(self):
        return self.__get(self.__is_ascii)

    def set_is_ascii(self, value: bool):
        self.__set(self.__is_ascii, value)
        return self

    def is_colored(self):
        return self.__get(self.__is_color)

    def set_is_colored(self, value: bool):
        self.__set(self.__is_color, value)
        return self
    
    def toggle_color(self):
        self.set_is_colored(not self.is_colored())
        return
    
    def toggle_nerdfonts(self):
        self.set_nerdfonts(not self.is_nerdfonts())
        return

    def get_diff_mode(self) -> str:
        return self.__get(self.__diffmode)

    def set_diff_mode(self, value: str):
        self.__set(self.__diffmode, value)
        return self

    def get_side_size(self):
        return self.__get(self.__sidesize)

    def set_side_size(self, value: int):
        self.__set(self.__sidesize, value)
        return self

    def get_lang_def(self):
        return self.__get(self.__langdef)

    def set_lang_def(self, value: str):
        self.__set(self.__langdef, value)
        return self




def random_get(dic: dict, str_key: str, mode:str = "static"):
    if mode == "static":
        count = sum([ord(c) for c in str_key])
        keys = list(dic.keys())
        return dic[keys[count % len(keys)]]
    else:
        keys = list(dic.keys())
        return dic[random.choice(keys)]

opening: Dict[str, str] = {}

opening["parrot"] = r"""
                           .    
                          | \/| 
                          ) )|/|
                    _----. /.'.'
.-._________..      .' @ _\  .' 
'.._______.   '.   /    (_| .') 
  '._____.  /   '-/      | _.'  
   '.______ (         ) ) \     
     '..____ '._       )  )     
        .' __.--\  , ,  // ((   
        '.'     |  \/   (_.'(   
                '   \ .'        
                 \   (          
                  \   '.        
                   \ \ '.)      
                    '-'-'       
"""

opening["estuda"] = r"""
 ,`````.          __||||___       
' Estuda`,       /_  ___   \      
'carniça!`.     /@ \/@  \   \     
 ` , . , '  `.. \__/\___/   /     
                 \_\/______/      
                 /     /\\\\\     
                |     |\\\\\\     
                 \      \\\\\\    
                  \______/\\\\    
            _______ ||_||_______  
           (______(((_(((______(@)
"""

# opening["alien"] = r"""
#        __.,,------.._
#       ,'"   _      _   "`.
#      /.__, ._  -=- _"`    Y
#     (.____.-.`      ""`   j
#      VvvvvvV`.Y,.    _.,-'       ,     ,     ,
#         Y    ||,   '"\         ,/    ,/    ./
#         |   ,'  ,     `-..,'_,'/___,'/   ,'/   ,
#    ..  ,;,,',-'"\,'  ,  .     '     ' ""' '--,/    .. ..
#  ,'. `.`---'     `, /  , Y -=-    ,'   ,   ,. .`-..||_|| ..
# ff\\`. `._        /f ,'j j , ,' ,   , f ,  \=\ Y   || ||`||_..
# l` \` `.`."`-..,-' j  /./ /, , / , / /l \   \=\l   || `' || ||...
#  `  `   `-._ `-.,-/ ,' /`"/-/-/-/-"'''"`.`.  `'.\--`'--..`'_`' || ,
#             "`-_,',  ,'  f    ,   /      `._    ``._     ,  `-.`'//         ,
#           ,-"'' _.,-'    l_,-'_,,'          "`-._ . "`. /|     `.'\ ,       |
#         ,',.,-'"          \=) ,`-.         ,    `-'._`.V |       \ // .. . /j
#         |f\\               `._ )-."`.     /|         `.| |        `.`-||-\\/
#         l` \`                 "`._   "`--' j          j' j          `-`---'
#          `  `                     "`,-  ,'/       ,-'"  /
#                                  ,'",__,-'       /,, ,-'
#                                  Vvv'            VVv'
# """

# opening["alien2"] = r"""
#                                          (  )  () @@  )  (( (
#                                      (      (  )( @@  (  )) ) (
#                                    (    (  ( ()( /---\   (()( (
#      _______                            )  ) )(@ !O O! )@@  ( ) ) )
#     <   ____)                      ) (  ( )( ()@ \ o / (@@@@@ ( ()( )
#  /--|  |(  o|                     (  )  ) ((@@(@@ !o! @@@@(@@@@@)() (
# |   >   \___|                      ) ( @)@@)@ /---\-/---\ )@@@@@()( )
# |  /---------+                    (@@@@)@@@( // /-----\ \\ @@@)@@@@@(  .
# | |    \ =========______/|@@@@@@@@@@@@@(@@@ // @ /---\ @ \\ @(@@@(@@@ .  .
# |  \   \\=========------\|@@@@@@@@@@@@@@@@@ O @@@ /-\ @@@ O @@(@@)@@ @   .
# |   \   \----+--\-)))           @@@@@@@@@@ !! @@@@ % @@@@ !! @@)@@@ .. .
# |   |\______|_)))/             .    @@@@@@ !! @@ /---\ @@ !! @@(@@@ @ . .
#  \__==========           *        .    @@ /MM  /\O   O/\  MM\ @@@@@@@. .
#     |   |-\   \          (       .      @ !!!  !! \-/ !!  !!! @@@@@ .
#     |   |  \   \          )            .  @@@@ !!     !!  .(. @.  .. .
#     |   |   \   \        (    /   .(  . \)). ( |O  )( O! @@@@ . )      .
#     |   |   /   /         ) (      )).  ((  .) !! ((( !! @@ (. ((. .   .
#     |   |  /   /   ()  ))   ))   .( ( ( ) ). ( !!  )( !! ) ((   ))  ..
#     |   |_<   /   ( ) ( (  ) )   (( )  )).) ((/ |  (  | \(  )) ((. ).
# ____<_____\\__\__(___)_))_((_(____))__(_(___.oooO_____Oooo.(_(_)_)((_
# """

opening["alien3"] = r"""
           \.   \.      __,-"-.__      ./   ./
       \.   \`.  \`.-'"" _,="=._ ""`-.'/  .'/   ./
        \`.  \_`-''      _,="=._      ``-'_/  .'/
         \ `-',-._   _.  _,="=._  ,_   _.-,`-' /
      \. /`,-',-._ ""  \ _,="=._ /   ""_.-,`-,'\ ./
       \`-'  /    `-._  "       "  _.-'    \  `-'/
       /)   (   BOM   \    ,-.    / ESTUDO  )   (\
    ,-'"     `-.       \  /   \  /       .-'     "`-,
  ,'_._         `-.____/ /  _  \ \____.-'         _._`,
 /,'   `.                \_/ \_/                .'   `,\
/'       )                  _                  (       `\
        /   _,-'"`-.  ,++|T|||T|++.  .-'"`-,_   \
       / ,-'        \/|`|`|`|'|'|'|\/        `-, \
      /,'             | | | | | | |             `,\
     /'               ` | | | | | '               `\
"""

opening["alien4"] = r"""
            ______              ______
           /___   \___\ || /___/   ___\
          //\]/\ ___  \\||//  ___ /\[/\\
          \\/[\//  _)   \/   (_  \\/]\//
           \___/ _/   o    o   \_ \___/
               _/                \_
              //'VvvvvvvvvvvvvvvV'\\
             ( \.'^^^^^^^^^^^^^^'./ )
              \____   . .. .   ____/
   ________        \ . .''. . /        ________
  /______  \________)________(________/ _______\
 /|       \ \  Estuda seu miserável  / /       |\
(\|____   / /                        \ \   ____|/)
"""

opening["alien5"] = r"""
                   ⢀⡀⠤⠤⠤⠄ ⠒⠢⣄    
                ⡠⠐⢈⠄        ⢸⠓⠄  
              ⠐⠈⠠⠊         ⡠⠊ ⠈⢂ 
            ⢀⠊ ⡐⠁        ⢠⢊⠔⠈   ⠆
           ⣠⡃ ⢰    ⢀⡠⠄⠐⠒ ⢸⢜⠄     
          ⡐⣁⡑ ⠘  ⢀⠔⢁⣀⣤⣤⣤⣒⣤ ⠈    ⡄
          ⢫⣿⢧ ⢸  ⣡⣶⣯⠭⢄⣀⣼⡏⠁⢀⡤   ⢐⠁
          ⢠⢿⣾⣧⠈ ⢠⣿⣿⣗⢢⣤⣿⡿⢋ ⡏    ⡌ 
   Gosto  ⠘⠳⠙⠻  ⠰⠿⠟⠛⠻⢍⠫⠒⠁⡰   ⢀⠜  
    de    ⠘⢄          ⢀⠠⢊ ⡇⢠⠒⠁   
   comer    ⠈⢦⠂    ⢠⠊⠁ ⢀⠄ ⡇⢸     
 cérebros    ⠘⢄⡄⢤⢄ ⠘⡄  ⡀⠄⢊⡅⡆⢆    
    de         ⢊   ⠈⢁⠴⠅⣀⣀⠘⢣⠠⠈⠢⢀  
  alunos       ⠈⠢⢄⣀⡠⠊  ⠈⢣ ⠈⠃⠡  ⠉⠐
preguiçosos             ⠰⠇  ⠐⡑⠤⢀ 
"""

intro: Dict[str, str] = {}
intro["shark"] = r"""
  _________         .    . r -> Roda sem testar             
 (..       \_    ,  |\  /| ↲ -> Testa usando casos de teste 
  \       O  \  /|  \ \/ / f -> FIXA a execução para        
   \______    \/ |   \  /       um único caso de teste      
      vvvv\    \ |   /  |  p -> Muda o arquivo PRINCIPAL    
      \^^^^  ==   \_/   |       para problemas de múltiplos 
       `\_   ===    \.  |       arquivos de código fonte    
       / /\_   \ /      |  m -> muda o MODO diff de vertical
       |/   \_  \|      /       para modo diff horizontal   
              \________/   t -> define o limite de TEMPO    
                           setas -> muda o teste            
"""

intro["cat"] = r"""
 ,_     _          r -> Roda sem testar             
 |\\_,-~/          ↲ -> Testa usando casos de teste 
 / _  _ |    ,--.  f -> FIXA a execução para        
(  @  @ )   / ,-'       um único caso de teste      
 \  _T_/-._( (     p -> Muda o arquivo PRINCIPAL    
 /         `. \         para problemas de múltiplos 
|         _  \ |        arquivos de código fonte    
 \ \ ,  /      |   m -> muda o MODO diff de vertical
  || |-_\__   /         para modo diff horizontal   
 ((_/`(____,-'     t -> define o limite de TEMPO    
                   setas -> muda o teste            
"""

intro["elephant"] = r"""
        ⣀⣀                r -> Roda sem testar             
      ⣰⣿⣿⣿⣿⣦⣀⣀⣀           ↲ -> Testa usando casos de teste 
      ⢿⣿⠟⠋⠉    ⠉⠑⠢⣄⡀      f -> FIXA a execução para        
     ⢠⠞⠁           ⠙⢿⣿⣿⣦⡀      um único caso de teste      
 ⣀  ⢀⡏ ⢀⣴⣶⣶⡄         ⢻⣿⣿⠇ p -> Muda o arquivo PRINCIPAL    
⣾⣿⣿⣦⣼⡀ ⢺⣿⣿⡿⠃    ⣠⣤⣄  ⠈⡿⠋       para problemas de múltiplos 
⢿⣿⣿⣿⣿⣇ ⠤⠌⠁ ⡀⢲⡶⠄⢸⣏⣿⣿   ⡇        arquivos de código fonte    
⠈⢿⣿⣿⣿⣿⣷⣄⡀  ⠈⠉⠓⠂ ⠙⠛⠛⠠ ⡸⠁   m -> muda o MODO diff de vertical
  ⠻⣿⣿⣿⣿⣿⣿⣷⣦⣄⣀    ⠑ ⣠⠞⠁         para modo diff horizontal   
   ⢸⡏⠉⠛⠛⠛⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⡄      t -> define o limite de TEMPO    
   ⠸        ⠈⠉⠛⢿⣿⣿⣿⣿⡄     setas -> muda o teste            
"""

compilling: Dict[str, str] = {}

# compilling["bloody"] = r"""
#  ▄████▄   ▒█████   ███▄ ▄███▓ ██▓███   ██▓ ██▓    ▄▄▄       ███▄    █ ▓█████▄  ▒█████  
# ▒██▀ ▀█  ▒██▒  ██▒▓██▒▀█▀ ██▒▓██░  ██▒▓██▒▓██▒   ▒████▄     ██ ▀█   █ ▒██▀ ██▌▒██▒  ██▒
# ▒▓█    ▄ ▒██░  ██▒▓██    ▓██░▓██░ ██▓▒▒██▒▒██░   ▒██  ▀█▄  ▓██  ▀█ ██▒░██   █▌▒██░  ██▒
# ▒▓▓▄ ▄██▒▒██   ██░▒██    ▒██ ▒██▄█▓▒ ▒░██░▒██░   ░██▄▄▄▄██ ▓██▒  ▐▌██▒░▓█▄   ▌▒██   ██░
# ▒ ▓███▀ ░░ ████▓▒░▒██▒   ░██▒▒██▒ ░  ░░██░░██████▒▓█   ▓██▒▒██░   ▓██░░▒████▓ ░ ████▓▒░
# ░ ░▒ ▒  ░░ ▒░▒░▒░ ░ ▒░   ░  ░▒▓▒░ ░  ░░▓  ░ ▒░▓  ░▒▒   ▓▒█░░ ▒░   ▒ ▒  ▒▒▓  ▒ ░ ▒░▒░▒░ 
#   ░  ▒     ░ ▒ ▒░ ░  ░      ░░▒ ░      ▒ ░░ ░ ▒  ░ ▒   ▒▒ ░░ ░░   ░ ▒░ ░ ▒  ▒   ░ ▒ ▒░ 
# ░        ░ ░ ░ ▒  ░      ░   ░░        ▒ ░  ░ ░    ░   ▒      ░   ░ ░  ░ ░  ░ ░ ░ ░ ▒  
# ░ ░          ░ ░         ░             ░      ░  ░     ░  ░         ░    ░        ░ ░  
# ░                                                                      ░               
# """


numbers = r"""
  __    __     _   ____  ____   ___   ___   ___  ____  ____  ___  
 /  \  /  \   / ) (___ \( __ \ / _ \ / __) / __)(__  )/ _  \/ _ \ 
(  0 )(_/ /  / /   / __/ (__ ((__  ((___ \(  _ \  / / ) _  (\__  )
 \__/  (__) (_/   (____)(____/  (__/(____/ \___/ (_/  \____/(___/ 
"""


executing: str = r"""
███████╗██╗  ██╗███████╗ ██████╗██╗   ██╗████████╗ █████╗ ███╗   ██╗██████╗  ██████╗ 
██╔════╝╚██╗██╔╝██╔════╝██╔════╝██║   ██║╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗██╔═══██╗
█████╗   ╚███╔╝ █████╗  ██║     ██║   ██║   ██║   ███████║██╔██╗ ██║██║  ██║██║   ██║
██╔══╝   ██╔██╗ ██╔══╝  ██║     ██║   ██║   ██║   ██╔══██║██║╚██╗██║██║  ██║██║   ██║
███████╗██╔╝ ██╗███████╗╚██████╗╚██████╔╝   ██║   ██║  ██║██║ ╚████║██████╔╝╚██████╔╝
╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ 
"""

compilling["computer"] = r"""
 ██████╗ ██████╗ ███╗   ███╗██████╗ ██╗██╗      █████╗ ███╗   ██╗██████╗  ██████╗ 
██╔════╝██╔═══██╗████╗ ████║██╔══██╗██║██║     ██╔══██╗████╗  ██║██╔══██╗██╔═══██╗
██║     ██║   ██║██╔████╔██║██████╔╝██║██║     ███████║██╔██╗ ██║██║  ██║██║   ██║
██║     ██║   ██║██║╚██╔╝██║██╔═══╝ ██║██║     ██╔══██║██║╚██╗██║██║  ██║██║   ██║
╚██████╗╚██████╔╝██║ ╚═╝ ██║██║     ██║███████╗██║  ██║██║ ╚████║██████╔╝╚██████╔╝
 ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ 
"""

# compilling["edge]"] = r"""
# ▄█▄    ████▄ █▀▄▀█ █ ▄▄  ▄█ █    ██      ▄   ██▄   ████▄
# █▀ ▀▄  █   █ █ █ █ █   █ ██ █    █ █      █  █  █  █   █
# █   ▀  █   █ █ ▄ █ █▀▀▀  ██ █    █▄▄█ ██   █ █   █ █   █
# █▄  ▄▀ ▀████ █   █ █     ▐█ ███▄ █  █ █ █  █ █  █  ▀████
# ▀███▀           █   █     ▐     ▀   █ █  █ █ ███▀       
#                ▀     ▀             █  █   ██            
#                                   ▀                     
# """

success: Dict[str, str] = {}


success["success"] = r"""
███████╗██╗   ██╗ ██████╗███████╗███████╗███████╗ ██████╗ 
██╔════╝██║   ██║██╔════╝██╔════╝██╔════╝██╔════╝██╔═══██╗
███████╗██║   ██║██║     █████╗  ███████╗███████╗██║   ██║
╚════██║██║   ██║██║     ██╔══╝  ╚════██║╚════██║██║   ██║
███████║╚██████╔╝╚██████╗███████╗███████║███████║╚██████╔╝
╚══════╝ ╚═════╝  ╚═════╝╚══════╝╚══════╝╚══════╝ ╚═════╝ 
"""

# success["success3"] = r"""
#   ██████  █    ██  ▄████▄  ▓█████   ██████   ██████  ▒█████  
# ▒██    ▒  ██  ▓██▒▒██▀ ▀█  ▓█   ▀ ▒██    ▒ ▒██    ▒ ▒██▒  ██▒
# ░ ▓██▄   ▓██  ▒██░▒▓█    ▄ ▒███   ░ ▓██▄   ░ ▓██▄   ▒██░  ██▒
#   ▒   ██▒▓▓█  ░██░▒▓▓▄ ▄██▒▒▓█  ▄   ▒   ██▒  ▒   ██▒▒██   ██░
# ▒██████▒▒▒▒█████▓ ▒ ▓███▀ ░░▒████▒▒██████▒▒▒██████▒▒░ ████▓▒░
# ▒ ▒▓▒ ▒ ░░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░░░ ▒░ ░▒ ▒▓▒ ▒ ░▒ ▒▓▒ ▒ ░░ ▒░▒░▒░ 
# ░ ░▒  ░ ░░░▒░ ░ ░   ░  ▒    ░ ░  ░░ ░▒  ░ ░░ ░▒  ░ ░  ░ ▒ ▒░ 
# ░  ░  ░   ░░░ ░ ░ ░           ░   ░  ░  ░  ░  ░  ░  ░ ░ ░ ▒  
#       ░     ░     ░ ░         ░  ░      ░        ░      ░ ░  
#                   ░                                          
# """

# success["success4"] = r"""
#   █████████                                                       
#  ███░░░░░███                                                      
# ░███    ░░░  █████ ████  ██████   ██████   █████   █████   ██████ 
# ░░█████████ ░░███ ░███  ███░░███ ███░░███ ███░░   ███░░   ███░░███
#  ░░░░░░░░███ ░███ ░███ ░███ ░░░ ░███████ ░░█████ ░░█████ ░███ ░███
#  ███    ░███ ░███ ░███ ░███  ███░███░░░   ░░░░███ ░░░░███░███ ░███
# ░░█████████  ░░████████░░██████ ░░██████  ██████  ██████ ░░██████ 
#  ░░░░░░░░░    ░░░░░░░░  ░░░░░░   ░░░░░░  ░░░░░░  ░░░░░░   ░░░░░░  
# """

# success["success5"] = r"""
# .▄▄ · ▄• ▄▌ ▄▄· ▄▄▄ ..▄▄ · .▄▄ ·       
# ▐█ ▀. █▪██▌▐█ ▌▪▀▄.▀·▐█ ▀. ▐█ ▀. ▪     
# ▄▀▀▀█▄█▌▐█▌██ ▄▄▐▀▀▪▄▄▀▀▀█▄▄▀▀▀█▄ ▄█▀▄ 
# ▐█▄▪▐█▐█▄█▌▐███▌▐█▄▄▌▐█▄▪▐█▐█▄▪▐█▐█▌.▐▌
#  ▀▀▀▀  ▀▀▀ ·▀▀▀  ▀▀▀  ▀▀▀▀  ▀▀▀▀  ▀█▄▀▪
# """

# success["success6"] = r"""
#    ▄▄▄▄▄   ▄   ▄█▄    ▄███▄     ▄▄▄▄▄    ▄▄▄▄▄   ████▄
#   █     ▀▄  █  █▀ ▀▄  █▀   ▀   █     ▀▄ █     ▀▄ █   █
# ▄  ▀▀▀▀▄ █   █ █   ▀  ██▄▄   ▄  ▀▀▀▀▄ ▄  ▀▀▀▀▄   █   █
#  ▀▄▄▄▄▀  █   █ █▄  ▄▀ █▄   ▄▀ ▀▄▄▄▄▀   ▀▄▄▄▄▀    ▀████
#          █▄ ▄█ ▀███▀  ▀███▀                           
#           ▀▀▀                                         
# """

# --------------------------------------------------------------

images: Dict[str, str] = {}

images["pink"] = r"""
Programando assim, você vai dominar o mundo!
                 /`.    /`.                       
                f   \  ,f  \                      
                |    \/-`\  \                     
                i.  _\';.,X j                     
                 `:_\ (  \ \',-.                  
                   .'"`\ a\eY' )               _,.
                   `._"\`-' `-/            .-;'  |
                     /;-`._.-';\.        ,',"    |
                   .'/   "'   | `\.-'""-/ /      j
                 ,/ /         i,-"        (  ,/  /
              .-' .f         .'            `"/  / 
             / ,,/ffj\      /          .-"`.'-.'  
            / /_\`--//)     \ ,--._ .-'_,-'; /    
           f  ".-"-._;'      `._ _.,-i; /_; /     
           `.,'   |; \          \`\_,/-'  \'      
            .'    l \ `.        /"\ _ \`  j       
            f      : `-'        `._;."/`-'        
            |      `.               ,7  \         
            l       j             .'/ - \`.       
           .j.  .   <            (.'    .\ \f`. |\
          ,' `.  \ / \           `|      \,'||-:j 
        .'  .'\   Y.  \___......__\ ._   /`.||    
__.._,-" .-"'"")  /' ,' _          \ |  /"-.`j""``
  .'_.-'"     / .("-'-"":\        ._)|_(__. "'    
 ;.'         /-'---"".--"'       /,_,^-._ .)      
 `:=.__.,itz `---._.;'
"""

images["batman"] = r"""
Não é o que sou por dentro, é o que eu faço que me define.
                     .  .          
                     |\_|\         
                     | a_a\        
                     | | "]        
                 ____| '-\___      
                /.----.___.-'\     
               //        _    \    
              //   .-. (~v~) /|    
             |'|  /\:  .--  / \    
            // |-/  \_/____/\/~|   
           |/  \ |  []_|_|_] \ |   
           | \  | \ |___   _\ ]_}  
           | |  '-' /   '.'  |     
           | |     /    /|:  |     
           | |     |   / |:  /\    
           | |     /  /  |  /  \   
           | |    |  /  /  |    \  
           \ |    |/\/  |/|/\    \ 
            \|\ |\|  |  | / /\/\__\
             \ \| | /   | |__      
                  / |   |____)     
                  |_/              
"""


images["vegeta"] = r"""
O miserável é um gênio!
    ⢨⠊ ⢀⢀   ⠈⠺⡵⡱   ⢠⠃ ⡀         ⡘⢰⡁⠉⠊⠙⢎⣆    ⢩⢀⠜   
   ⢠⠃  ⢸⢸⡀    ⠘⢷⡡  ⠎ ⢰⣧  ⠈⡆       ⠈⣐⢤⣀⣀⢙⠦    ⡇    
  ⢀⠃   ⡌⢸⠃   ⢀  ⠑⢧⡸ ⢀⣿⢻⡀  ⣻     ⣠⡴⠛⠉   ⠑⢝⣦   ⢰⠠⠁  
  ⠌   ⡘⣖⣄⢃   ⠈⢦⡀ ⡜⡇ ⣼⠃⠈⢷⣶⢿⠟   ⢠⠞⠁ ⣀⠄⠂⣶⣶⣦⠆⠋⠓ ⢀⣀⡇   
⠡⡀⡇ ⢰⣧⢱⠊⠘⡈⠄  ⡀⠘⣿⢦⣡⢡⢰⡇⢀⠤⠊⡡⠃  ⢀⡴⠁⢀⠔⠊  ⢠⣿⠟⠁ ⢀ ⢀⠾⣤⣀  ⡠
⡀⠱⡇ ⡆⢃   ⠃   ⣧⣀⣹⡄⠙⡾⡏ ⡌⣠⡾⠁  ⣠⠊⢠⠔⠁    ⣸⡏   ⢨⣪⡄⢻⣥⠫⡳⢊⣴
  ⢡⢠ ⢸⡆ ⣀    ⠈⣛⢛⣁⣀⠘⣧⣀⢱⡿  ⢀⡔⢁⢔⠕⠉⠐⣄⣠⠤⠶⠛⠁⢀⣀  ⠉⠁⠈⠷⣞⠔⡕⣿
⢄⡀⠘⢸ ⣘⠇        ⠉⠐⠤⡑⢎⡉⢨⠁ ⣠⢏⠔⠁⠘⣤⠴⢊⣡⣤⠴⠖⠒⠻⠧⣐⠓    ⠈ ⡜ ⠇
⠤⡈⠑⠇⠡⣻⢠⠊⠉⠉⠉⠑⠒⠤⣀   ⠈⣾⣄⢘⣫⣜⠮⢿⣆⡴⢊⢥⡪⠛⠉    ⢀⠄⠂⠁      ⢧⡀⠈
⠁⠈⠑⠼⣀⣁⣇ ⣴⡉⠉⠉ ⠒⡢⠌⣐⡂⠶⣘⢾⡾⠿⢅ ⣠⣶⡿⠓⠁⢠⠖⣦⡄   ⠊         ⠈⢎⢳
    ⠉⣇⣿⢜⠙⢷⡄   ⣄⣠⠼⢶⡛⣡⢴ ⢀⠛⠱⡀    ⢀⠎ ⠁            ⢠⡋⠮⡈
  ⢀⣖⠂⢽⡈ ⠈⠑⠻⡦⠖⢋⣁⡴⠴⠊⣉⡠⢻⡖⠪⢄⡀⢈⠆  ⢠⠊⢠             ⢀⠤⡵⢤⣃
  ⠸⢠⡯⣖⢵⡀  ⣠⣤⠮⠋⠁     ⠸⣌⢆⢱⡾⠃⢀⠠⠔⠁⣀⢸     ⡄       ⡸⠚⡸⠈⠁
⠤⢀⣀⢇⢡⠸⡗⢔⡄⠸⠊           ⠉⡩⠔⢉⡠⠔⠂⠉⢀⠆            ⢠⢁⠎⢀⡠⠔
   ⠘⡌⢦⡃⣎⠘⡄        ⠠⡟⠠⡐⣋⠤ ⣀⠤⠐⠂⠉⠁             ⡸⢉⠉⠁  
⠤   ⠰⡀⠈⠻⡤⠚⢄  ⢠       ⠈⠂⠒⠉                  ⢠⠃⢸ ⢀⠤⠊
⣀    ⠘⠢⡑⢽⡬⢽⢆ ⠈           ⣠⣤⡶⠟⣉⣉⢢          ⢀⠇ ⠈⡖⠓⠒⠂
 ⢈⣑⣒⡤⠄ ⠈⠑⠥⣈⠙⠧           ⢰⣁⠔⠊⠁        ⡜   ⣠⡻   ⠇⠐⡔⣡
⠉⠉⠁ ⠒⠒⠒⠒ ⠤⠤⠍⣒⡗⢄⡀        ⠈           ⡸  ⢠⡞⢡⠃   ⢸ ⠸⣡
            ⢠  ⠈⣶⢄⡀                ⡰⠁⣠⡔⠉ ⡎    ⢸  ⠃
         ⢠⠇⣀⢼   ⢉⡄⠈⠐⠤⣀         ⢀⡀ ⡜⡡⣾⠃  ⠸      ⡧⢄⡈
       ⣀⠤⠚⠉ ⡆   ⠈⡵⢄⡀  ⠙⠂⠄⣀⡀⠤⠊⠉⢀⣀⣠⡴⢿⣟⠞  ⢀⠇      ⡗⠢⢌
    ⡠⠔⠉  ⢀⡠⡤⠇  ⢀ ⠰⣣⠈⠐⠤⡀ ⡀⠈⠙⢍⠉⣉⠤⠒⠉⣠⣟⢮⠂⡄ ⣼⠁ ⡆    ⢡⣀ 
⣿⡷⠖⠉  ⡠⠔⣪⣿⠟⣫   ⢸  ⢩⢆  ⠈⠑⢳⠤⠄⠠⠭⠤⠐⠂⢉⣾⢮⠃⢠⠃⢰⡹ ⢰     ⢸⡉⣳
⠉ ⢀⡠⠒⠉⣠⠾⠋⢁⠔⠹   ⡈⡇  ⢫⣆   ⠘⣆      ⣘⢾⠃⢀⠏⣠⡳⠁ ⣾      ⠈⠉
"""



images["esqueleto"] = r"""
Você venceu o desafio, mas não a guerra!
Espero você no próximo nível!
                              _.--""-._                     
  .                         ."         ".                   
 / \    ,^.         /(     Y             |      )\          
/   `---. |--'\    (  \__..'--   -   -- -'""-.-'  )         
|        :|    `>   '.     l_..-------.._l      .'          
|      __l;__ .'      "-.__.||_.-'v'-._||`"----"            
 \  .-' | |  `              l._       _.'                   
  \/    | |                   l`^^'^^'j                     
        | |                _   \_____/     _                
        j |               l `--__)-'(__.--' |               
        | |               | /`---``-----'"1 |  ,-----.      
        | |               )/  `--' '---'   \'-'  ___  `-.   
        | |              //  `-'  '`----'  /  ,-'   I`.  \  
      _ L |_            //  `-.-.'`-----' /  /  |   |  `. \ 
     '._' / \         _/(   `/   )- ---' ;  /__.J   L.__.\ :
      `._;/7(-.......'  /        ) (     |  |            | |
      `._;l _'--------_/        )-'/     :  |___.    _._./ ;
        | |                 .__ )-'\  __  \  \  I   1   / / 
        `-'                /   `-\-(-'   \ \  `.|   | ,' /  
                           \__  `-'    __/  `-. `---'',-'   
                              )-._.-- (        `-----'      
                             )(  l\ o ('..-.                
                       _..--' _'-' '--'.-. |                
                __,,-'' _,,-''            \ \               

"""

images["coiote"] = r"""
Você fez essa questão muito rápido, da próxima vez
vou aumentar a dificuldade!
                      _                                   
                     : \                                  
                     ;\ \_                   _            
                     ;@: ~:              _,-;@)           
                     ;@: ;~:          _,' _,'@;           
                     ;@;  ;~;      ,-'  _,@@@,'           
                    |@(     ;      ) ,-'@@@-;             
                    ;@;   |~~(   _/ /@@@@@@/              
                    \@\   ; _/ _/ /@@@@@@;~               
                     \@\   /  / ,'@@@,-'~                 
                       \\  (  ) :@@(~                     
                    ___ )-'~~~~`--/ ___                   
                   (   `--_    _,--'   )                  
                  (~`- ___ \  / ___ -'~)                  
                 __~\_(   \_~~_/   )_/~__                 
 /\ /\ /\     ,-'~~~~~`-._ 0\/0 _,-'~~~~~`-.              
| |:  ::|    ;     ______ `----'  ______    :             
| `'  `'|    ;    {      \   ~   /      }   |             
 \_   _/     `-._      ,-,' ~~  `.-.      _,'        |\   
   \ /_          `----' ,'       `, `----'           : \  
   |_( )                `-._/#\_,-'                  :  ) 
 ,-'  ~)           _,--./  (###)__                   :  : 
 (~~~~_)          /       ; `-'   `--,               |  ; 
 (~~~' )         ;       /@@@@@@.    `.              | /  
 `.HH~;        ,-'  ,-   |@@@ @@@@.   `.             .')  
  `HH `.      ,'   /     |@@@@@ @@@@.  `.           / /(~)
   HH   \_   ,'  _/`.    |@@@@@ @@@@@;  `.          ; (~~)
   ~~`.   \_,'  /   ;   .@@@@@ @@@@@@;\_  \___      ; H~\)
       \_     _/    `.  |@@@@@@ @@@@@;  \     `----'_HH[~)
         \___/       `. :@@@@@ @@@@@@'   \__,------' HH ~ 
        ______        ; |@@@@@@ @@@'                 HH   
      _)      \_,     ; :@@@@@@@@@;                  ~~   
    _;          \\   ,' |@@@@@@@@@:                       

"""

images["piupiu"] = r"""
Eu acho que eu vi um programador!
                 $                
              $  $   $$           
              $ $$ $$             
         $$$$      $$$$$$         
       $$                $$       
     $$        $$          $$     
   $$                        $$   
  $$                          $$  
  $                           $ $ 
 $                $             $ 
 $             $$$$              $
 $            $$ $           $   $
 $          $$$$$$       $$$$    $
 $         $$$$$$$      $$  $    $
  $        $$$$$ $     $$$$$$   $ 
  $$       $     $    $$$$$$   $$ 
   $$      $    $    $$$$     $   
    $      $   $     $       $    
    $      $$$$         $  $$     
    $$               $$$  $       
     $$$       $$$$$      $       
        $$$     $$       $$       
            $$     $$$$$$         
          $$      $$ $            
       $$$$        $ $$           
         $  $$     $   $          
    $$$$$$ $       $  $           
  $$   $$$$ $      $   $$$$$$$    
  $$      $$$$     $ $$     $$    
  $          $$$$$$$$         $   
   $$         $   $          $    
    $$$$$$$$$$$   $$$$$$$$$$$ ~*  
"""

images["saitama"] = r"""
Se garantiu
        ⣠⣴⣶⡋⠉⠙⠒⢤⡀     ⢠⠖⠉⠉⠙⠢⡄ 
      ⢀⣼⣟⡒⠒     ⠙⣆   ⢠⠃     ⠹⡄
      ⣼⠷⠖        ⠘⡆  ⡇       ⢷
      ⣷⡒  ⢐⣒⣒⡒ ⣐⣒⣒⣧  ⡇ ⢠⢤⢠⡠  ⢸
     ⢰⣛⣟⣂ ⠘⠤⠬⠃⠰⠑⠥⠊⣿ ⢴⠃ ⠘⠚⠘⠑⠐ ⢸
     ⢸⣿⡿⠤     ⢀⡆  ⣿  ⡇       ⣸
     ⠈⠿⣯⡭    ⢀⣀   ⡟  ⢸      ⢠⠏
       ⠈⢯⡥⠄      ⡼⠁   ⠳⢄⣀⣀⣀⡴⠃ 
         ⢱⡦⣄⣀⣀⣀⣠⠞⠁      ⠈⠉    
       ⢀⣤⣾⠛⠃   ⢹⠳⡶⣤⡤⣄         
    ⣠⢴⣿⣿⣿⡟⡷⢄⣀⣀⣀⡼⠳⡹⣿⣷⠞⣳        
   ⢰⡯⠭⠹⡟⠿⠧⠷⣄⣀⣟⠛⣦⠔⠋⠛⠛⠋⠙⡆       
  ⢸⣿⠭⠉ ⢠⣤   ⠘⡷⣵⢻    ⣼ ⣇       
  ⡇⣿⠍⠁ ⢸⣗⠂   ⣧⣿⣼    ⣯ ⢸  
"""

images["cool"] = r"""
Essa foi show de bola!
       ⢀⣠⣤⣴⡾⠻⢶⣤⡀ 
     ⢀⣶⠟⠉⠉    ⠉⢷⡄
   ⠉⢿⣿⣿⣿⠏⠈⢿⣿⣿⣿⡿⢟⣿
    ⢸⡏ ⢠⣀ ⢀⡤   ⢨⣿
    ⠸⣿⡀ ⠉⠉⠉  ⢀⣠⡾⠃
     ⠈⠻⠷⠶⣶⡶⠾⠿⠛⠉  
 ⢀⡀     ⢀⣿       
⠿⢿⣧⡀    ⣸⣟       
  ⠘⢿⡄ ⣠⡾⢻⣿⣄      
    ⢿⣴⡟ ⢸⡏⠹⣧     
    ⠈⠛  ⢸⣟ ⠹⣧    
"""

images["among"] = r"""
Sossegue, você não é um importor
           ⣠⣤⣤⣤⣤⣤⣶⣦⣤⣄⡀         
        ⢀⣴⣿⡿⠛⠉⠙⠛⠛⠛⠛⠻⢿⣿⣷⣤⡀      
        ⣼⣿⠋       ⢀⣀⣀⠈⢻⣿⣿⡄     
       ⣸⣿⡏   ⣠⣶⣾⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣄    
       ⣿⣿⠁  ⢰⣿⣿⣯⠁       ⠈⠙⢿⣷⡄  
  ⣀⣤⣴⣶⣶⣿⡟   ⢸⣿⣿⣿⣆          ⣿⣷  
 ⢰⣿⡟⠋⠉⣹⣿⡇   ⠘⣿⣿⣿⣿⣷⣦⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿  
 ⢸⣿⡇  ⣿⣿⡇    ⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃  
 ⣸⣿⡇  ⣿⣿⡇     ⠉⠻⠿⣿⣿⣿⣿⡿⠿⠿⠛⢻⣿⡇   
 ⣿⣿⠁  ⣿⣿⡇                ⢸⣿⣧   
 ⣿⣿   ⣿⣿⡇                ⢸⣿⣿   
 ⣿⣿   ⣿⣿⡇                ⢸⣿⣿   
 ⢿⣿⡆  ⣿⣿⡇                ⢸⣿⡇   
 ⠸⣿⣧⡀ ⣿⣿⡇                ⣿⣿⠃   
  ⠛⢿⣿⣿⣿⣿⣇     ⣰⣿⣿⣷⣶⣶⣶⣶⠶ ⢠⣿⣿    
       ⣿⣿     ⣿⣿⡇ ⣽⣿⡏⠁  ⢸⣿⡇    
       ⣿⣿     ⣿⣿⡇ ⢹⣿⡆   ⣸⣿⠇    
       ⢿⣿⣦⣄⣀⣠⣴⣿⣿⠁ ⠈⠻⣿⣿⣿⣿⡿⠏     
       ⠈⠛⠻⠿⠿⠿⠿⠋⠁               
"""

images["heart"] = r"""
O código ficou lindo dessa vez!
     ⣀⣀⣀⡀          ⣀⣠⣠⣴⣦⣤⣤⣄⣀   
  ⣰⣼⣿⣯⢭⣿⣿⣿⣻⣶⣤⡀  ⢀⣠⣾⣿⣿⣾⣿⣿⣿⣽⣿⣿⣻⣦⡀
 ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⢀⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢡⠊⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠎⠠⠐⡉⢉⠁⠘⣭⣿⣿⣿⣿⣿⣿⣿⡿ 
⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠈⠄⡁⠂⢀⠂⡬⣾⣿⣿⣿⣿⣿⣿⣿⣿⠁ 
 ⠈⢿⣿⣿⣿⣿⣿⣶⣤⣖⡂⠌⠐⠠⠐⢨⢀⠄⠘⢜⢿⣿⣿⣿⣿⣿⣿⠃  
   ⠹⣿⣿⣿⣿⣿⣿⣿⣿⠆⠁⢂⠅⣒⡈⠤⠈⡈ ⠻⣿⣿⣿⡿⠃   
    ⠙⢿⣿⣿⣿⣿⣿⣿⣄⡦⣠⣾⣿⣿⣿⣷⣾⣤⣗⣹⣿⡟     
      ⠘⠿⣿⣿⣿⣿⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏      
        ⠻⢿⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠏       
          ⠘⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁        
             ⠙⠿⢿⣿⣿⣿⡿⠋          
Ou será que não?
"""

images["pikachu"] = r"""
        Picapi!          
⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿    ⣠⣤⣶⣶
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿   ⢰⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⣀⣾⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡏⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿
⣿⣿⣿⣿⣿⣿   ⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠁ ⣿
⣿⣿⣿⣿⣿⣿⣧⡀    ⠙⠿⠿⠿⠻⠿⠿⠟⠿⠛⠉     ⣸⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄ ⡀               ⢀⣴⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏              ⠠⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡟  ⢰⣹⡆      ⣭⣷   ⠸⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠃  ⠈⠉  ⠤⠄   ⠉⠁    ⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢾⣿⣷    ⡠⠤⢄   ⠠⣿⣿⣷ ⢸⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡀⠉     ⢄ ⢀    ⠉⠉⠁  ⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣧       ⠈          ⢹⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃                 ⢸⣿⣿
"""

images["yoda"] = r"""
Que a força esteja com você
 ⢀⣠⣄⣀⣀⣀               ⣀⣤⣴⣶⡾⠿⠿⠿⠿⢷⣶⣦⣤⣀⡀                     
⢰⣿⡟⠛⠛⠛⠻⠿⠿⢿⣶⣶⣦⣤⣤⣀⣀⡀⣀⣴⣾⡿⠟⠋⠉        ⠉⠙⠻⢿⣷⣦⣀         ⢀⣀⣀⣀⣀⣀⣀⣀⡀
 ⠻⣿⣦⡀ ⠉⠓⠶⢦⣄⣀⠉⠉⠛⠛⠻⠿⠟⠋⠁   ⣤⡀  ⢠   ⣠    ⠈⠙⠻⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠟⠛⠛⢻⣿
  ⠈⠻⣿⣦    ⠈⠙⠻⢷⣶⣤⡀    ⢀⣀⡀ ⠙⢷⡀⠸⡇ ⣰⠇ ⢀⣀⣀      ⣀⣠⣤⣤⣶⡶⠶⠶⠒⠂  ⣠⣾⠟
    ⠈⢿⣷⡀      ⠈⢻⣿⡄⣠⣴⣿⣯⣭⣽⣷⣆ ⠁    ⢠⣾⣿⣿⣿⣿⣦⡀ ⣠⣾⠟⠋⠁       ⣠⣾⡟⠁ 
     ⠈⢻⣷⣄       ⣿⡗⢻⣿⣧⣽⣿⣿⣿⣧  ⣀⣀ ⢠⣿⣧⣼⣿⣿⣿⣿⠗⠰⣿⠃        ⣠⣾⡿⠋   
       ⠙⢿⣶⣄⡀    ⠸⠃⠈⠻⣿⣿⣿⣿⣿⡿⠃⠾⣥⡬⠗⠸⣿⣿⣿⣿⣿⡿⠛ ⢀⡟      ⣀⣠⣾⡿⠋     
         ⠉⠛⠿⣷⣶⣤⣤⣄⣰⣄  ⠉⠉⠉⠁ ⢀⣀⣠⣄⣀⡀ ⠉⠉⠉  ⢀⣠⣾⣥⣤⣤⣤⣶⣶⡿⠿⠛⠉       
             ⠈⠉⢻⣿⠛⢿⣷⣦⣤⣴⣶⣶⣦⣤⣤⣤⣤⣬⣥⡴⠶⠾⠿⠿⠿⠿⠛⢛⣿⣿⣿⣯⡉⠁           
               ⠈⣿⣧⡀⠈⠉ ⠈⠁⣾⠛⠉⠉          ⣀⣴⣿⠟⠉⣹⣿⣇            
               ⢀⣸⣿⣿⣦⣀   ⢻⡀       ⢀⣠⣤⣶⣿⠋⣿⠛⠃ ⣈⣿⣿            
               ⣿⡿⢿⡀⠈⢹⡿⠶⣶⣼⡇ ⢀⣀⣀⣤⣴⣾⠟⠋⣡⣿⡟ ⢻⣶⠶⣿⣿⠛⠋            
              ⠘⣿⣷⡈⢿⣦⣸⠇⢀⡿⠿⠿⡿⠿⠿⣿⠛⠋⠁ ⣴⠟⣿⣧⡀⠈⢁⣰⣿⠏              
               ⢸⣿⢻⣦⣈⣽⣀⣾⠃ ⢸⡇ ⢸⡇ ⢀⣠⡾⠋⢰⣿⣿⣿⣿⡿⠟⠋               
               ⠘⠿⢿⣿⣿⡟⠛⠃  ⣾  ⢸⡇⠐⠿⠋  ⣿⢻⣿⣿                   
                  ⢸⣿⠁⢀⡴⠋ ⣿  ⢸⠇     ⠁⢸⣿⣿                   
                 ⢀⣿⡿⠟⠋   ⣿  ⣸       ⢸⣿⣿                   
                 ⢸⣿⣁⣀    ⣿⡀ ⣿      ⢀⣈⣿⣿                   
                 ⠘⠛⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠟⠛⠋                   
"""

images["vader"] = r"""
Sua falta de fé é perturbadora.
                 ⢀⣀⡀   ⢀⣀               
            ⣠⣤⣶⣾⣿⡉⢤⣍⡓⢶⣶⣦⣤⣉⠒⠤⡀           
         ⢀⣴⣿⣿⣿⣿⣿⣿⣷⡀⠙⣿⣷⣌⠻⣿⣿⣿⣶⣌⢳⡀         
        ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠈⢿⣿⡆⠹⣿⣿⣿⣿⣷⣿⡀        
       ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠹⣿⡄⢻⣿⣿⣿⣿⣿⣧        
      ⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⣿⣿⣷⣽⣷⢸⣿⡿⣿⡿⠿⠿⣆       
      ⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄   ⠐⠾⢭⣭⡼⠟⠃⣤⡆⠘⢟⢺⣦⡀     
      ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢛⣥⣶⠾⠿⠛⠳⠶⢬⡁  ⠘⣃⠤⠤⠤⢍⠻⡄    
      ⣿⣿⣿⣿⣿⣿⣿⡿⣫⣾⡿⢋⣥⣶⣿⠿⢿⣿⣿⣿⠩⠭⢽⣷⡾⢿⣿⣦⢱⡹⡀   
      ⣿⣿⣿⣿⣿⣿⡟⠈⠛⠏⠰⢿⣿⣿⣧⣤⣼⣿⣿⣿⡏⠩⠽⣿⣀⣼⣿⣿⢻⣷⢡   
     ⢰⣿⣿⣿⣿⣿⣿⢁⣿⣷⣦⡀ ⠉⠙⠛⠛⠛⠋⠁⠙⢻⡆ ⢌⣉⠉⠉ ⠸⣿⣇⠆  
    ⢀⣾⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⠷⣄⢠⣶⣾⣿⣿⣿⣿⣿⠁  ⢿⣿⣿⣿⣷⠈⣿⠸⡀ 
    ⣼⣿⣿⣿⣿⣿⣿ ⣌⡛⠿⣿⣿ ⠈⢧⢿⣿⡿⠟⠋⠉⣠⣤⣤⣤⣄⠙⢿⣿⠏⣰⣿⡇⢇ 
   ⣼⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣶⣤⣙⠣⢀⠈⠘⠏  ⢀⣴⢹⡏⢻⡏⣿⣷⣄⠉⢸⣿⣿⣷⠸⡄
  ⣸⣿⣿⣿⣿⣿⣿⣿⠁⣾⣟⣛⠛⠛⠻⠿⠶⠬⠔ ⣠⡶⠋⠿⠈⠷⠸⠇⠻⠏⠻⠆⣀⢿⣿⣿⡄⢇
 ⢰⣿⣿⣿⣿⠿⠿⠛⠋⣰⣿⣿⣿⣿⠿⠿⠿⠒⠒⠂ ⢨⡤⢶⣶⣶⣶⣶⣶⣶⣶⣶⠆⠃⣀⣿⣿⡇⣸
⢀⣿⣿⠿⠋⣡⣤⣶⣾⣿⣿⣿⡟⠁ ⣠⣤⣴⣶⣶⣾⣿⣿⣷⡈⢿⣿⣿⣿⣿⠿⠛⣡⣴⣿⣿⣿⣿⠟⠁
⣼⠋⢁⣴⣿⣿⣿⣿⣿⣿⣿⣿   ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣎⠻⠟⠋⣠⣴⣿⣿⣿⣿⠿⠋⠁  
⢿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿ ⣴ ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣠⣾⣿⠿⠿⠟⠋⠁     
 ⠉⠛⠛⠿⠿⠿⢿⣿⣿⣿⣵⣾⣿⣧⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠏           
                  ⠉⠉⠉⠉⠉⠉⠉⠁              
"""

images["mario"] = r"""
Vamos lá. Nossa grande aventura começa agora!
                      ⢀⣀⣠⣤⣤⣤⣄⣀            
                   ⣠⣴⡾⣻⣿⣿⣿⣿⣯⣍⠛⠻⢷⣦⣀        
                ⢀⣴⣿⠟⢁⣾⠟⠋⣁⣀⣤⡉⠻⣷⡀ ⠙⢿⣷⣄      
       ⢀⡀      ⣰⣿⠏  ⢸⣿ ⠼⢋⣉⣈⡳⢀⣿⠃   ⠙⣿⣦⡀    
      ⢰⡿⠿⣷⡀   ⣼⣿⠃  ⣀⣤⡿⠟⠛⠋⠉⠉⠙⢛⣻⠶⣦⣄⡀ ⠘⣿⣷⡀   
⢠⣾⠟⠳⣦⣄⢸⡇ ⠈⣷⡀ ⣼⣿⡏⢀⣤⡾⢋⣵⠿⠻⢿⠋⠉⠉⢻⠟⠛⠻⣦⣝⠻⣷⣄⠸⣿⣿   
⠘⣧   ⠙⢿⣿  ⢸⣷ ⣿⣿⣧⣾⣏⡴⠛⢡⠖⢛⣲⣅  ⣴⣋⡉⠳⡄⠈⠳⢬⣿⣿⣿⡿   
 ⠘⠷⣤⣀⣀⣀⣽⡶⠛⠛⠛⢷⣿⣿⣿⣿⣏  ⡏⢰⡿⢿⣿  ⣿⠻⣿ ⡷ ⣠⣾⣿⡿⠛⠷⣦  
  ⢀⣾⠟⠉⠙⣿⣤⣄ ⢀⣾⠉ ⢹⣿⣿⣷ ⠹⡘⣷⠾⠛⠋⠉⠛⠻⢿⡴⢃⣄⣻⣿⣿⣷  ⢹⡇ 
  ⢸⡇⠈⠉⠛⢦⣿⡏ ⢸⣧ ⠈⠻⣿⡿⢣⣾⣦⣽⠃       ⣷⣾⣿⡇⠉⢿⡇ ⢀⣼⠇ 
  ⠘⣷⡠⣄⣀⣼⠇   ⠻⣷⣤⣀⣸⡇ ⠹⣿⣿⣦⣀    ⢀⣴⣿⣿⡟  ⢸⣷⣾⡿⠃  
   ⠈⠻⢦⣍⣀⣀⣀⡄ ⣰⣿⡿⠿⢿⣇  ⠉⠛⠻⣿⣿⡷⠾⣿⣿⡿⠉⠁  ⢀⣾⠋⠁    
      ⠈⠉⠉⠙⠿⢿⣿⣇  ⠈⢿⣧⣄   ⢹⣷⣶⣶⣾⣿⡇  ⣀⣴⡿⣧⣄⡀    
            ⠙⢿⣷⡀  ⠙⢿⣿⣶⣤⡀⠻⢤⣀⡤⠞⢀⣴⣿⣿⠟⢷⡀⠙⠻⣦⣄  
              ⠈⢻⣦ ⢠⡟⠁⠙⢻⣿⠷⠶⣶⠶⠾⠛⠙⣿⠇  ⢻⡄  ⠙⢷⡀
               ⣸⣿⡀⣿⠁⣤⣤⡄⢻⡶⠶⠛⠛⠛⠛⠛⣿⢠⣾⣷⣆⢻⡀  ⠈⣷
               ⣿⣿⣿⣿⢸⣿⣿⣿⡈⢿⡀     ⡿⢸⣿⣿⣿⢸⡇   ⡟
               ⠈⠉⠉⠉⠈⠉⠉⠉⠁⠈⠁    ⠈⠁⠈⠉⠉⠉ ⠁  ⠈⠁
"""

images["mandalorian"] = r"""
Como deve ser
                     ⢀⣀⣀⣀⣀                        
                 ⢀⣠⠴⠚⣹⠁⣶⢲⢈⠉⠓⠶⢤⡀                   
               ⣠⠞⠉ ⢀⣾⢻ ⣿⡈⢸    ⠉⠳⢄⡀                
             ⢠⠞    ⣈⣿⣾⣾⣿⡇⢸       ⠙⢄               
           ⢀⡴⠃ ⢀⡀ ⣴⣿⡏⣿⣿⣿⡇⣼⡇       ⠈⠳⣄⡀            
       ⣠⡴⠶⠟⠋  ⡄⢸⡇⢸⣿⣼⣧⣿⣿⣿⣁⣿⣤⣄⣀⣀ ⢀    ⠈⠙⠛⠒⠦⠄        
            ⣠⣦⣷⣾⡿⠿⢿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⣿⣓⣲⠲⠦⢤⣀              
          ⢀⣴⣿⣫⣭⣼⣶⣿⠿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣿⣟⢻⣶⣌⢻⣶            
         ⢀⣿⡿⡿⢿⠓⠒⣛⠻⣿⣟⣿⣿⣿⣿⣿⣿⡏⠙⠋⠛    ⠈⠉⣿⢹⡆           
         ⠸⣿⡇⢀⣀  ⣿⢀ ⠸⣿⣿⣿⣿⣿⣿⠁     ⣠⣴⣶⣦⣼⣿⣇           
         ⠈⣿⡇⣿⣿⣿⣦⡹⣆  ⣿⣿⣿⣿⣿⣿   ⣴⣿⣾⣿⣿⢿⣿⣿⣿⠛           
          ⢘⣿⣿⣿⣿⣿⣿⡝⣧ ⢹⣿⣿⣿⣿⣿ ⢀⣼⣿⣿⣿⣿⣿⣿⠃⣿⣿            
          ⠈⢻⣿⢸⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡗⠈⣼⣿⢿⣿⡿⠿⢿⣯ ⠿⣿            
           ⢸⣿⣸⡇⠈⠙⢿⣷⢿⡘⣿⣿⣿⣿⠃⢠⣿⣿⡿⠉   ⢻⡀⢀⣿            
           ⢸⣿⣿   ⠈⢻⡟⣇⣇⣿⣿⣿ ⢸⣿⡿⠁     ⢷⣄⢻            
           ⢸⣿⡏     ⣿⢿⣿⣿⣿⣿ ⣾⣿⠃      ⠘⣿⡟            
           ⠘⠻⠧⣄⡀   ⢸⣾⣿⣿⣿⣿ ⣿⡟    ⣀⣠⣥⣶⣿⣦⣄⡀          
               ⠉⠙⠲⣦⣄⣿⣿⣿⣿⣿⣷⣿⣧⣴⣶⡾⣛⣯⣭⣷⠤⠶⠤⢬⣭⢽⣆⡀⢠⣶⣶⣶⠶⠶⢤
               ⣀⣀⡤⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣟⢿⠏⣉⣡⣤⣶⣾⠿⣿⣿⣿⣿⠛⢸⣾⡿⠛⠛⠛⠶
           ⣀⣠⣤⣿⣛⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⣷⣿⣿⡿⢟⣿⡟⣰⣾⠋     
       ⣠⣴⡶⣫⣽⢿⣯⣽⣿⣿⣿⣿⠿⠛⠁⢈⣹⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⣤⣴⣿⠛⢰⣿⠇      
      ⣰⣿⣿⣼⣟⣽⣼⣿⣿⣿⣿⣯⣷⢍⣣⣶⣿⣿⣿⣿⣿⣿⣿⠟⠁     ⢸⣿⣿⡟ ⣧⣿ ⡀     
"""


images["minion"] = r"""
Bananaaaa!
              ⣀ ⠤⠤⠤ ⣀       
           ⡠⠐⢉⠴⣚⠉⣙⠢⢄⡤⢞⡂⢀⣐⢄  
          ⡔⡤⣞⢁⠊⢀⣀⠐⢿⡄⠰⢁⡀⠈⠺⣦⢡ 
         ⢰⣿⣗⣟⡸ ⠻⡿⠃⢸⣇⢃⠿⠿  ⣽⢸ 
         ⠁ ⠈⠙⢷⣴⡀ ⠠⣪⣾⣷⡄⡀⠠⣐⢕⠁ 
 ⢰⡦      ⡇    ⠙⠲⡖⠓⠉⠁⠈⠉⠒ ⠈⢸  
⢶⣿⣷⣤⢀⣀⡀  ⣏⡑⠢⢄   ⠈⠐ ⠐     ⡸⡀ 
⠛⠛⠛⠟ ⠤⠤⠌⢉ ⠈⠓⢬⣿⣦⡤⣤⣤⠤⠤⣤⣤⣤⣤⣚⣔⣄ 
         ⡇  ⡤⠂  ⢀⠤⠤⢄⡨⠔⠒⢍⠉⢁⣯⡆
         ⡗⢤⡤⣬   ⢇   ⠁  ⡸⢰⣿⣿⡿
         ⠘⢌⡿⣽⡀  ⠈⠒⢄⡀ ⢀⠔⠁⠈⠙⡋ 
           ⠑⠳⢧⣠⣤⣄⣠⣀⣈⣱⡥⠤⠴⠦⠴⠃ 
              ⢹⣿⣿ ⣿⣿⣿⣄      
              ⠙⠉⠉ ⠈⠉⠉⠉      
"""

images["minions2"] = r"""
Banana banana bananáaaaaa!
            ⣀⢀⣠⣤⣄⡀⢀⣀          
         ⣠⡶⠛⢉⠤⣀⠤⡠⢫⠵⠶⢩⡢        
 ⣀      ⢰⠋ ⣠⢡⠋⠉⠙⣆⢂⣤⡄⠈⡇⡇  ⣀⣶⣄⢤ 
⢠⢇⠓⠒⣂⡤⡀ ⡆ ⡜⣿⣜⢄⣿⢆⠜⣤⣝⣓⣢⠜ ⡠⢛⠧⠬⠭⠸⠇
⠈⠒⠓⠂⠙⠓⢌⠢⢷⡫⠐⠉⠛⠴⠶⠖⠊ ⠉⠉ ⢸⠌⡰⠁     
       ⠑⡀⠙⢕⢦  ⠠⣲⣒⠲⢲⠎⢻⢈⣷       
        ⠸⡀ ⢣⡑⡄ ⠑⠠⠄⠘⠴⠂⣸⣹       
         ⠃  ⢹⣼⡶⣄    ⡴⢿⢻       
         ⢀   ⡝⠁ ⠙⠒⠒⠋ ⢸⢸       
         ⢸⢄⣀⣀⡇  ⡖⢦⣴⠊⡆⢸⣸       
         ⢰ ⠉⢸⠁ ⠸⡇⣞⣯⡷⡇⢨⢹       
         ⣸⡀⠔⠃   ⠑⠬⠭⠝ ⣈⡾⡄      
        ⡴⢣⠑⢄⣀⣀⣀⣀⣀ ⠤⣐⢞⣿⡡⠃      
        ⠈⠁⠉⠉       ⠈⠫⠙        
"""

images["slayer"] = r"""
Não há atalhos, apenas trabalho duro.
Treine duro e seja paciente. Vai valer a pena.
⠏⠁⠈⠙⠛⢿⣿⣿⣿⣿⣿⣿⣿⡟ ⠈⠻⣿⣿⣿⣿⣿⠟⢡⡿⢿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
    ⢀⣎⣏⡏⣟⠛⠿⠿⡟⢁⣀⣀⣠⡼⠟⠛⠉  ⠉⠐⠋  ⠛⠋⠭⠾⢿⣿⣿⠟⣫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣦⣶⡀   ⠉⠛⣿⣿⣷⣿⣇⣠⠟⠋⠁  ⢀⡄       ⣀⣠⡤⠴⠒⠋⠁⣰⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣷  ⡀   ⠉⠉⡿⠋⠁⡠⢀⠄⡠⠔⠋⢀⣀⠔ ⢀⡤⠚⣽⡟⠋   ⢀⡜⢱⠃⠉⣩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣦⡀⢹   ⢀⡞⠁⡰⠛⣡⢃⣾⠁⠤⡾⢋⣀⡀⠠⠊ ⢾⣏⡾ ⢀⣠⡴⠿⠙⣿⠃ ⠙⠛⢉⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⡄  ⡜ ⠐⡅⡜⡇⢠⠃⡠⠊⠐⠝⠋    ⠈⠙⢁⠔⣯⡝⢁⡶⢾⣿⠇   ⠐⠺⠿⢻⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡀⣠⡇ ⣠⡇⡸ ⢣⠎⢀⣀⣤⣴⣶⠟⠛      ⣭⣷⣤⡴⠋        ⠙⣽⡿⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢿⡇⢀⡟⠃⣡⡿⠃⣰⣾⡯⠚⠉⣀⣠⣄⣤            ⢀ ⢀⡈⠁   ⣠⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⢸⣷⠸⠁⢲⡏⢀⣾⣿⠏⣠⠞⠁ ⢾⣿⣽⡆⡀ ⣠        ⣀⡠⠄   ⢀⡾⢧⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣳⣿⣿⣆ ⢸⠁⠸⣿⠏⣰⣿ ⡀  ⢁⣻⣧⣷⣿⡽⠃      ⠉    ⢠⣶⠯⣄⣠⡽⠿⢿⣿
⣿⣿⣿⣿⣿⣿⣟⡁⢈⠟⣁    ⠋⢰⣿⡿⣧⣌⣒⣒⣿⣞⣿⣿⠋           ⢀⣸⣯⠽⠋⠁     
⣿⣿⣿⠿⣿⣿⡿⠟⠁⠊⠱⣣⣶⡀  ⢘⡛⠓⠚⣛⣋⣛⣸⠭⠞⠁          ⣀⡠⣞⡋⠁        
⣿⣿⡃ ⠘⣿⢤⡀   ⣹⣿⡟ ⢀⡎⢱ ⡀                ⣉⡥⠖⠉          
⣿⣟⢿ ⢆⠘⢦⡈⢦⡠⡺⠋⠉⠠⢊⡝ ⢰⣧⡈⠓⢤⣀             ⣽⠶⠄           
⣿⣿⣼⣷⠈⢳⣄⠙⠲⣧  ⣠⠖⠋⠙⠢⠼⠁⠙⠶ ⠈⠉⠛⠤         ⣀⠉⠉            
⣿⣿⣷⣍  ⠻⠷⠄⢘⣧⣞⣡⣶⣏⠉⣳ ⣠⣤⣀ ⢤⣠⡐⠦⣄⡀    ⢀⡐⠒⠉              
⣿⣿⣿⣿⣿⣷⣶⣄⣀⣸⣿⣿⣿⣿⣿⣶⣿⣆⣻⣿⣿⣷⣶⢭⣿⣦⣶⠿⠾⣗⢒⠿ ⠁                
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⠁⠙⠂⢀⡉⣁⡠⠴⠛⠉⠁                  
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀  ⠈ ⣄              ⣠⣤⣶⠶⠖⣶⠁ 
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣛⡦ ⣀⣨⠟⠲⠤⠤⠬⣷⣀          ⣠⣴⠟⢁⡀ ⣼⠇  
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣶⣬⣿⣿⣡⣵⣖⣤⣀⣤⣈⣙⣶⣦⣤⣀⣀⣠⡤⠶⠟⠋⠁  ⠉⢷⠉   
"""

images["jujutsu"] = r"""
Não sei como vou me sentir quando estiver morto, 
mas não quero me arrepender da maneira como vivi.
   ⣀                      
⢠⣀⡀⡏⠳⣄   ⢀⡀ ⢠             
⡤⠵ ⢀⡶⠛⠁⢢⢄⡜⠱⡾⠍⠧⠲⡇⣀⡄        
⠈⢶⣤⠛⠁⣀⡹⠉        ⠰⠥⣤       
  ⠁ ⠠⣿⢃⢀⣤⣤⡴⣰⢰⣠⢠  ⢨⣷⡆      
     ⠝⢿⠙⢯⣟ ⣱⡿⠌⡷⣿⣾⣿⡿⠙⢦     
      ⣸ ⠼   ⠃⣠⠄⠘⡟⢘⣄ ⠈⢷    
     ⠘⡏⠉ ⡐⢢ ⢀⡀ ⢰⠖⡩⠊ ⣠⠋    
      ⢈⣷⢄⡑⠚⢀⡠⠤⣒⠡⠊⢀⣠⣾⣿⣦    
    ⢀⣴⣿⣿⣿⣍⠫⠇⠐⠉⢒⣠⣴⣿⣿⣿⣿⣿⡆   
  ⡤⢐⠚⣿⣿⣿⣿⣿⣶⣶⣶⣶⣾⣿⣛⠟⠛⣿⣿⣿⡇   
 ⢸⠐⠠⢌⣺⣿⠿⠛⠻⣿⣿⣿⣿⣿⣿ ⠄ ⠈⣿⣿⣷   
  ⠣⢌⡹⠋⠁ ⢀⣠⣿⣿⣿⣿⣿⣿⣯⣭⣀⣴⣿⣿⣿⠇  
     ⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣍   
   ⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇  
  ⢀⣾⣿⣿⣿⣿⣿⡿⠏⠁ ⠈⠉⠙⢿⣿⣿⣿⣿⣿⣿⣿⣇ 
  ⣼⣿⣿⣿⣿⡿⠋⠁       ⠙⢿⣿⣿⣿⣿⣿⣿⡆
 ⠘⠛⣿⡿⠛⠋              ⢿⣿⣏⠉⠉
⢀⠤⣾⠛⣿                ⠾⣐⣚⣦ 
⠉⠉⠉⠉⠁                     
"""


images["gollum"] = r"""
Meu precioso!
        ⣀⣠⣴⣶⡿⠟⠋⠁              
     ⢀⣴⣾⣿⣿⣿⠋      ⠈           
   ⢀⣼⡿⠛⠻⣿⣿⠃⢀            ⢀     
  ⢠⣿⣿⠃⢰⣆⠘⢿⡦⠈            ⠸     
 ⢠⣿⣿⣿ ⠙⢿⡆⠈⠁                 ⡀ 
⢀⣿⣿⣿⣿⢀⠐⢿⠃                  ⢀⣷ 
⠈⠉⠉⠙⠛⠃⣷⣮⠃ ⢀⣀⣀⡀             ⢸⣿⡇
      ⠘⣿⡄⠐⠚⢆⠁⠙⢻⣶⣦⣄⡀⡀       ⠘⠋⠁
  ⢀⣶⡀⠐⣠⣿⣷⣤⡀⠐⠙⠶⠶⠿⠿⠛⠿⣿⣿⣿⣤⣴⣀  ⣴⢎ 
  ⠈⣿⣿⣾⣿⣿⣿⣿⣇⣠⠴⠖⠲⡂   ⠹⣿⣟⡛⠹⠛⠂⠘⣡⡿ 
   ⢻⣿⣿⣿⣿⣿⡇⢹⣧   ⠱⢀⣀⡠⠲⣄⣹⣿⡏ ⣠⣾⣿⠃ 
   ⠸⣿⣿⣿⣿⣿⡇ ⠁⠙⣢⣄⣀    ⢹⣿⣿⣫⣾⣿⡿⠃  
    ⠙⢩⢻⣿⣿⣷⡀  ⢈⡙⠛⠿⠓⠐⠉ ⢸⣿⣿⣿⠟⠁   
       ⠽⢀⣤⡀ ⢠⣤⡈⠉⠁⠠⠤  ⠘⠿⠋⠁     
         ⠉⠛⠿⠶⢾⣭⢤⡾ ⠠⠒          
"""

quit_msgs = [
        "Deus abençoe, vá em paz",
        "Bye bye",
        "Vou sentir saudades",
        "Volte quando estiver mais descansado",
        "Espero que tenha aprendido algo novo hoje",
        "Cada pequena vitória merece ser comemorada",
        "Obrigado pelo tempo juntos",
        "Até a próxima",
        "Um abraço, seja feliz", 
        "Durma cedo, amanhã você pode continuar", 
        "Vá, mais volte",
        "Arri égua, já vai?", 
        "Capando o gato tão cedo?",
        "Vai porque quer",
        "Fique mais um pouquinho", 
        "Vamos lá, pegue um café (ou chá) e volte outra hora",
        "Foque em avançar um passo por vez",
        "O caminho é mais importante que a chegada",
        "Lembre de dar bons nomes para as variáveis e métodos", 
        "Você também está programando para outros seres humanos lerem, faça algo organizado",
        "Seja criterioso com a indentação e as regras de estilo, faça algo belo",
        "Está precisando de mais conselhos? Experimente rezar",
        "Não se repita, refatore seu código para tirar as redundâncias",
        "São necessárias umas 1000 horas pra ser bom em algo",
        "Só é fracasso quando você desiste, espaireça e tente de novo",
        "Parar e descansar é importante também",
        "Se for pra descansar, largue o celular",
        "Traga uma garrafa de água próxima vez, facilite o acesso",
        "Toda capacidade que não é usada, se perde, movimente-se",
        "Te vejo depois do exercício. Malhe, corra, dance, e depois volte",
        "Se você não se der valor, ninguém vai. Invista em você",
        "Tem exercícios que vão ser bem complicados, tire um tempo para pensar longe do computador",
        "Use as inteligências artificiais com sabedoria, depois, tente refazer a tarefa sem elas",
        "Lembre de pedir ajuda quando precisar", 
        "Você não está sozinho, peça ajuda se preciso", 
        "É justo que o que muito vale, muito custe", 
        "Aprender a se divertir é parte essencial do aprendizado", 
        "Esse miserável é um miserável",
        "Você é importante e precioso, mesmo que seu código tenha ficado uma porcaria",
        "Alguns tem mais dificuldades que outros, tenha paciência consigo mesmo",
        "Se você precisa de mais tempo que seus colegas pra aprender, se dê mais tempo", 
    ]
class LabelFactory:
    def __init__(self):
        self._label = ""
        self._index = -1

    def index(self, value: int):
        try:
            self._index = int(value)
        except ValueError:
            raise ValueError("Index on label must be a integer")
        return self

    def label(self, value: str):
        self._label = value
        return self

    def generate(self):
        label = LabelFactory.trim_spaces(self._label)
        label = LabelFactory.remove_old_index(label)
        if self._index != -1:
            index = str(self._index).zfill(2)
            if label != "":
                return index + " " + label
            else:
                return index
        return label

    @staticmethod
    def trim_spaces(text):
        parts = text.split(" ")
        parts = [word for word in parts if word != '']
        return " ".join(parts)

    @staticmethod
    def remove_old_index(label):
        split_label = label.split(" ")
        if len(split_label) > 0:
            try:
                int(split_label[0])
                return " ".join(split_label[1:])
            except ValueError:
                return label

tko_guide = """
       ╔════ TKO GUIA COMPACTO ════╗
╔══════╩═════ BAIXAR PROBLEMA ═════╩═══════╗
║        tko down <curso> <label>          ║
║ exemplo poo  : tko down poo carro        ║
║ exemplo fup  : tko down fup opala        ║
╟─────────── EXECUTAR SEM TESTAR ──────────╢
║          tko run <cod, cod...>           ║
║exemplo ts  : tko run solver.ts           ║
║exemplo cpp : tko run main.cpp lib.cpp    ║
╟──────── ABRIR O MODO INTERATIVO ─────────╢
║              tko play <curso>            ║
║exemplo:      tko play fup                ║
╟──────────── RODAR OS TESTES ─────────────╢
║   tko run cases.tio <cod, ...> [-i ind]  ║
║ exemplo: tko run cases.tio main.ts       ║
╟── DEFINIR EXTENSÃO PADRÃO DOS RASCUNHOS ─╢
║           tko config -l <ext>            ║
║     exemplo c : tko config -l c          ║
║  exemplo java : tko config -l java       ║
╟─────────── MUDAR VISUALIZAÇÃO ───────────╢
║             tko config <--opcao>         ║
║DiffMode: tko config [--side  | --down ]  ║
║Cores   : tko config [--mono  | --color  ]║
║Encoding: tko config [--ascii | --unicode]║
╚══════════════════════════════════════════╝
"""

bash_guide = """
       ╔═══ BASH  GUIA COMPACTO ════╗
╔══════╩════ MOSTRAR E NAVEGAR ═════╩══════╗
║Mostrar arquivos  : ls                    ║
║Mostrar ocultos   : ls -la                ║
║Mudar de pasta    : cd _nome_da_pasta     ║
║Subir um nível    : cd ..                 ║
╟─────────────── CRIAR ────────────────────╢
║Criar um arquivo  : touch _nome_do_arquivo║
║Criar uma pasta   : mkdir _nome_da_pasta  ║
╟─────────────── REMOVER ──────────────────╢
║Apagar um arquivo : rm _nome_do_arquivo   ║
║Apagar uma pasta  : rm -r _nome_da_pasta  ║
║Renomear ou mover : mv _antigo _novo      ║
╟─────────────── CONTROLAR ────────────────╢
║Últimos comandos  : SETA PRA CIMA         ║
║Limpar console    : Control L             ║
║Cancelar execução : Control C             ║
║Finalizar entrada : Control D             ║
╚══════════════════════════════════════════╝
"""



def get_md_link(title: str) -> str:
    if title is None:
        return ""
    title = title.lower()
    out = ""
    for c in title:
        if c == " " or c == "-":
            out += "-"
        elif c == "_":
            out += "_"
        elif c.isalnum():
            out += c
    return out

class Title:
    @staticmethod
    def extract_title(readme_file):
        title = open(readme_file).read().split("\n")[0]
        parts = title.split(" ")
        if parts[0].count("#") == len(parts[0]):
            del parts[0]
        title = " ".join(parts)
        return title

class RemoteCfg:
    def __init__(self, url: Optional[str] = None):
        self.user = ""
        self.repo = ""
        self.branch = ""
        self.folder = ""
        self.file = ""
        if url is not None:
            self.from_url(url)

    def from_url(self, url: str):
        if url.startswith("https://raw.githubusercontent.com/"):
            url = url.replace("https://raw.githubusercontent.com/", "")
            parts = url.split("/")
            self.user = parts[0]
            self.repo = parts[1]
            self.branch = parts[2]
            self.folder = "/".join(parts[3:-1])
            self.file = parts[-1]
        elif url.startswith("https://github.com/"):
            url = url.replace("https://github.com/", "")
            parts = url.split("/")
            self.user = parts[0]
            self.repo = parts[1]
            self.branch = parts[3]
            self.folder = "/".join(parts[4:-1])
            self.file = parts[-1]
        else:
            raise Exception("Invalid URL")

    def get_raw_url(self):
        return "https://raw.githubusercontent.com/" + self.user + "/" + self.repo + "/" + self.branch + "/" + self.folder + "/" + self.file

    def download_absolute(self, filename: str):
        [tempfile, __content] = urllib.request.urlretrieve(self.get_raw_url(), filename)
        content = ""
        try:
            content = open(tempfile, encoding="utf-8").read()
        except:
            content = open(tempfile).read()
        with open(filename, "w", encoding="utf-8") as f:
            absolute = Absolute.relative_to_absolute(content, self)
            f.write(absolute.encode("utf-8").decode("utf-8"))
        return

    def __str__(self):
        return f"user: ({self.user}), repo: ({self.repo}), branch: ({self.branch}), folder: ({self.folder}), file: ({self.file})"

    def read(self, cfg_path: str):
        if not os.path.isfile(cfg_path):
            print("no remote.cfg found")

        config = configparser.ConfigParser()
        config.read(cfg_path)

        self.user   = config["DEFAULT"]["user"]
        self.repo   = config["DEFAULT"]["rep"]
        self.branch = config["DEFAULT"]["branch"]
        self.folder = config["DEFAULT"]["base"]
        self.tag    = config["DEFAULT"]["tag"]

    @staticmethod
    def search_cfg_path(source_dir) -> Optional[str]:
        # look for the remote.cfg file in the current folder
        # if not found, look for it in the parent folder
        # if not found, look for it in the parent's parent folder ...

        path = os.path.abspath(source_dir)
        while path != "/":
            cfg_path = os.path.join(path, "remote.cfg")
            if os.path.isfile(cfg_path):
                return cfg_path
            path = os.path.dirname(path)
        return None

class Absolute:

    # processa o conteúdo trocando os links locais para links absolutos utilizando a url remota
    @staticmethod
    def __replace_remote(content: str, remote_raw: str, remote_view: str, remote_folder: str) -> str:
        if content is None or content == "":
            return ""
        if not remote_raw.endswith("/"):
            remote_raw += "/"
        if not remote_view.endswith("/"):
            remote_view += "/"
        if not remote_folder.endswith("/"):
            remote_folder += "/"

        #trocando todas as imagens com link local
        regex = r"!\[(.*?)\]\((\s*?)([^#:\s]*?)(\s*?)\)"
        subst = r"![\1](" + remote_raw + r"\3)"
        result = re.sub(regex, subst, content, 0)


        regex = r"\[(.+?)\]\((\s*?)([^#:\s]*?)(\s*?/)\)"
        subst = r"[\1](" + remote_folder + r"\3)"
        result = re.sub(regex, subst, result, 0)

        #trocando todos os links locais cujo conteudo nao seja vazio
        regex = r"\[(.+?)\]\((\s*?)([^#:\s]*?)(\s*?)\)"
        subst = r"[\1](" + remote_view + r"\3)"
        result = re.sub(regex, subst, result, 0)

        return result

    @staticmethod
    def relative_to_absolute(content: str, cfg: RemoteCfg):
        user_repo = cfg.user + "/" + cfg.repo
        raw = "https://raw.githubusercontent.com"
        github = "https://github.com"
        remote_raw    = f"{raw}/{user_repo}/{cfg.branch}/{cfg.folder}"
        remote_view    = f"{github}/{user_repo}/blob/{cfg.branch}/{cfg.folder}"
        remote_folder = f"{github}/{user_repo}/tree/{cfg.branch}/{cfg.folder}"
        return Absolute.__replace_remote(content, remote_raw, remote_view, remote_folder)

    @staticmethod
    def from_file(source_file, output_file, cfg: RemoteCfg, hook):
        content = open(source_file, encoding="utf-8").read()
        content = Absolute.relative_to_absolute(content, cfg)
        open(output_file, "w").write(content)
        
class RemoteMd:

    # @staticmethod
    # def insert_preamble(lines: List[str], online: str, tkodown: str) -> List[str]:

    #     text = "\n- Veja a versão online: [aqui.](" + online + ")\n"
    #     text += "- Para programar na sua máquina (local/virtual) use:\n"
    #     text += "  - `" + tkodown + "`\n"
    #     text += "- Se não tem o `tko`, instale pelo [LINK](https://github.com/senapk/tko#tko).\n\n---"

    #     lines.insert(1, text)

    #     return lines

    # @staticmethod
    # def insert_qxcode_preamble(cfg: RemoteCfg, content: str, hook) -> str:
    #     base_hook = os.path.join(cfg.base, hook)

    #     lines = content.split("\n")
    #     online_readme_link = os.path.join("https://github.com", cfg.user, cfg.repo, "blob", cfg.branch, base_hook, "Readme.md")
    #     tkodown = "tko down " + cfg.tag + " " + hook
    #     lines = RemoteMd.insert_preamble(lines, online_readme_link, tkodown)
    #     return "\n".join(lines)

    @staticmethod
    def run(remote_cfg: RemoteCfg, source: str, target: str, hook) -> bool:    
        content = open(source).read()
        content = Absolute.relative_to_absolute(content, remote_cfg)
        open(target, "w").write(content)
        return True


languages_avaliable = ["c", "cpp", "py", "ts", "js", "java", "go"]

class RepSource:
    def __init__(self, file: str = "", url: str = ""):
        self.file: str = ""
        if file != "":
            self.file = os.path.abspath(file)
        self.url: str = url

    def set_file(self, file: str):
        self.file = os.path.abspath(file)
        return self

    def set_url(self, url: str):
        self.url = url
        return self

    def get_file(self, rep_dir: str) -> str:
        # arquivo existe e é local
        if self.file != "" and os.path.exists(self.file) and self.url == "":
            return self.file

        # arquivo não existe e é remoto
        if self.url != "" and (self.file == "" or not os.path.exists(self.file)):
            cache_file = os.path.join(rep_dir, ".cache.md")
            os.makedirs(rep_dir, exist_ok=True)
            cfg = RemoteCfg(self.url)
            try:
                cfg.download_absolute(cache_file)
            except urllib.error.URLError:
                print("fail: Não foi possível baixar o arquivo do repositório")
                if os.path.exists(cache_file):
                    print("Usando arquivo do cache")
                else:
                    raise Warning("fail: Arquivo do cache não encontrado")
            return cache_file

        raise ValueError("fail: arquivo não encontrado ou configurações inválidas para o repositório")

    def to_dict(self) -> Dict[str, Any]:
        return {
            "file": self.file,
            "url": self.url
        }

    def from_dict(self, data: Dict[str, Any]):
        self.file = data.get("file", "")
        self.url = data.get("url", "")
        return self    

class RepData:

    def __init__(self, json_file: str = ""):
        self.json_file: str = json_file
        self.data: Dict[str, Any] = {}

    __expanded = "expanded"
    __new_items = "new_items"
    __tasks = "tasks"
    __flags = "flags"
    __lang = "lang"
    __index = "index"

    defaults = {
        __expanded: [],
        __tasks: {},
        __flags: {},
        __new_items: [],
        __lang: "",
        __index: 0
    }

    def get_index(self) -> int:
        return self.__get(RepData.__index)

    def get_expanded(self) -> list:
        return self.__get(RepData.__expanded)

    def get_new_items(self) -> list:
        return self.__get(RepData.__new_items)
    
    def get_tasks(self) -> Dict[str, Any]:
        return self.__get(RepData.__tasks)
    
    def get_flags(self) -> Dict[str, Any]:
        return self.__get(RepData.__flags)
    
    def get_lang(self) -> str:
        return self.__get(RepData.__lang)

    def set_expanded(self, value: list):
        return self.__set(RepData.__expanded, value)
    
    def set_new_items(self, value: list):
        return self.__set(RepData.__new_items, value)
    
    def set_tasks(self, value: Dict[str, Any]):
        return self.__set(RepData.__tasks, value)
    
    def set_flags(self, value: Dict[str, Any]):
        return self.__set(RepData.__flags, value)
    
    def set_lang(self, value: str):
        return self.__set(RepData.__lang, value)
    
    def set_index(self, value: int):
        return self.__set(RepData.__index, value)

    def __get(self, key: str) -> Any:
        if key not in self.defaults:
            raise ValueError(f"Key {key} not found in RepSettings")
        value = self.data.get(key, RepData.defaults[key])
        if type(value) != type(RepData.defaults[key]):
            return RepData.defaults[key]
        return value

    def __set(self, key: str, value: Any):
        self.data[key] = value
        return self

    def load_defaults(self):
        for key in RepData.defaults:
            self.data[key] = RepData.defaults[key]
        return self

    def load_data_from_json(self):
        with open(self.json_file, encoding="utf-8") as f:
            self.data = json.load(f)
        return self


    def save_data_to_json(self):
        if not os.path.exists(os.path.dirname(self.json_file)):
            os.makedirs(os.path.dirname(self.json_file))
        # filter keys that are not in defaults
        for key in list(self.data.keys()):
            if key not in RepData.defaults:
                del self.data[key]

        with open(self.json_file, "w", encoding="utf-8") as f:
            f.write(json.dumps(self.data, indent=4))
        return self

    def __str__(self) -> str:
        return (
            f"data: {self.data}\n"
        )



class FileSource:
    def __init__(self, label, input_file, output_file):
        self.label = label
        self.input_file = input_file
        self.output_file = output_file

    def __eq__(self, other):
        return self.label == other.label and self.input_file == other.input_file and \
                self.output_file == other.output_file


class PatternLoader:
    pattern: str = ""

    def __init__(self):
        parts = PatternLoader.pattern.split(" ")
        self.input_pattern = parts[0]
        self.output_pattern = parts[1] if len(parts) > 1 else ""
        self._check_pattern()

    def _check_pattern(self):
        self.__check_double_wildcard()
        self.__check_missing_wildcard()

    def __check_double_wildcard(self):
        if self.input_pattern.count("@") > 1 or self.output_pattern.count("@") > 1:
            raise ValueError("  fail: the wildcard @ should be used only once per pattern")

    def __check_missing_wildcard(self):
        if "@" in self.input_pattern and "@" not in self.output_pattern:
            raise ValueError("  fail: is input_pattern has the wildcard @, the input_patter should have too")
        if "@" not in self.input_pattern and "@" in self.output_pattern:
            raise ValueError("  fail: is output_pattern has the wildcard @, the input_pattern should have too")

    def make_file_source(self, label):
        return FileSource(label, self.input_pattern.replace("@", label), self.output_pattern.replace("@", label))

    def get_file_sources(self, filename_list: List[str]) -> List[FileSource]:
        input_re = self.input_pattern.replace(".", "\\.")
        input_re = input_re.replace("@", "(.*)")
        file_source_list = []
        for filename in filename_list:
            match = re.findall(input_re, filename)
            if not match:
                continue
            label = match[0]
            file_source = self.make_file_source(label)
            if file_source.output_file not in filename_list:
                print("fail: file " + file_source.output_file + " not found")
            else:
                file_source_list.append(file_source)
        return file_source_list

    def get_odd_files(self, filename_list) -> List[str]:
        matched = []
        sources = self.get_file_sources(filename_list)
        for source in sources:
            matched.append(source.input_file)
            matched.append(source.output_file)
        unmatched = [file for file in filename_list if file not in matched]
        return unmatched


class Token:
    def __init__(self, text: str = "", fmt: str = "", ):
        if not isinstance(text, str):
            raise TypeError("text must be a string")
        self.text = text
        self.fmt = fmt

    def __eq__(self, other: Any):
        if not isinstance(other, Token):
            return False
        return self.text == other.text and self.fmt == other.fmt

    def __len__(self):
        return len(self.text)
    
    def __add__(self, other: Any):
        return Sentence().add(self).add(other)

    def __str__(self):
        return f"('{self.text}', '{self.fmt}')"

def RToken(fmt: str, text: str) -> Token:
    return Token(text, fmt)

class Sentence:
    def __init__(self, value: Union[str, Tuple[str, str]] = ""):
        self.data: List[Token] = []
        self.add(value)
    
    def clone(self):
        other = Sentence()
        other.data = [v for v in self.data]
        return other

    def setup(self, data: List[Token]):
        self.data = []
        for d in data:
            for c in d.text:
                self.data.append(Token(c, d.fmt))
        return self

    def __getitem__(self, index: int) -> Token:
        if index < 0 or index >= len(self):
            raise IndexError("index out of range")
        return self.data[index]

    def __len__(self):
        return self.len()
    
    def __add__(self, other: Any):
        return Sentence().add(self).add(other)

    def __eq__(self, other: Any):
        if len(self.data) != len(other.data):
            return False
        for i in range(len(self.data)):
            if self.data[i] != other.data[i]:
                return False
        return True


    def __str__(self):
        return "".join([str(d) for d in self.resume()])
    
    def resume(self) -> List[Token]:
        if len(self.data) == 0:
            return []
        
        new_data: List[Token] = [Token("", self.data[0].fmt)]
        for d in self.data:
            if d.fmt == new_data[-1].fmt:
                new_data[-1].text += d.text
            else:
                new_data.append(Token())
                new_data[-1].text = d.text
                new_data[-1].fmt = d.fmt
        return new_data
    
    def resume_val_fmt(self) -> Tuple[str, str]:
        fmt = []
        val = []
        for d in self.data:
            fmt.append(" " if d.fmt == "" else d.fmt[0])
            val.append(d.text)
        return "".join(val), "".join(fmt)


    # search for a value inside the tokens and replace it with a new value and fmt
    def replace(self, old: str, token: Token):
        old_list: List[str] = [c for c in old]
        new_list = [c for c in token.text]
        new_list.reverse()

        index = 0
        while index < len(self.data) - len(old_list) + 1:
            found = True
            for i in range(len(old_list)):
                if self.data[index + i].text != old_list[i]:
                    found = False
                    break
            if found:
                for _ in range(len(old_list)):
                    del self.data[index]
                for c in new_list:
                    self.data.insert(index, Token(c, token.fmt))
                index += len(new_list)
            else:
                index += 1
        return self

    def plus(self, qtd: int) -> Sentence:
        output = Sentence()
        for i in range(qtd):
            output.add(self)
        return output

    def add(self, value: Union[str, Token, Tuple[str, str], Sentence]):
        if isinstance(value, str):
            if value != "":
                for c in value:
                    self.data.append(Token(c))
        elif isinstance(value, Token):
            if value.text != "":
                for c in value.text:
                    self.data.append(Token(c, value.fmt))
        elif isinstance(value, Sentence):
            self.data += value.data
        else:
            raise TypeError("unsupported type '{}'".format(type(value)))
        return self
    
    def addf(self, fmt: str, text: Any):
        if not isinstance(text, str):
            raise TypeError("fmt must be a string")
        self.add(Token(text, fmt))
        return self

    def ljust(self, width: int, filler: Token = Token(" ")):
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            suffix = [Token(char, fmt) for _ in range(width - total)]
            self.data = self.data + suffix
        return self
    
    def rjust(self, width: int, filler: Token = Token(" ")):
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            prefix = [Token(char, fmt) for _ in range(width - total)]
            self.data = prefix + self.data
        return self
    
    def center(self, width: int, filler: Token = Token(" ")):
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            left = (width - total) // 2
            right = width - total - left
            prefix = [Token(char, fmt) for _ in range(left)]
            suffix = [Token(char, fmt) for _ in range(right)]
            self.data = prefix + self.data + suffix
        return self
    
    def len(self):
        return len(self.data)
    
    def get_data(self):
        return self.data
    
    def get_text(self) -> str:
        return "".join([t.text for t in self.data])

    def trim_alfa(self, limit: int):
        i = len(self.data) - 1
        size = len(self.data)
        locked = False
        while i >= 0 and size > limit:
            if self.data[i].text == "[":
                locked = False
                i -= 1
            elif self.data[i].text == "]":
                locked = True
                i -= 1
            elif not locked and self.data[i].text != " ":
                del self.data[i]
                size -= 1
                i -= 1
            else:
                i -= 1

    def cut_begin(self, qtd: int):
        if qtd > len(self.data):
            self.data = []
        else:
            self.data = self.data[qtd:]
        return self

    def trim_spaces(self, limit: int):
        return self

    def trim_end(self, width: int):
        if self.len() > width:
            self.data = self.data[:width]
        return self

    def join(self, array: List[Sentence]):
        out = Sentence()
        for i, a in enumerate(array):
            if i != 0:
                out.add(self)
            out.add(a)
        return out
            


class Flag:
    def __init__(self):
        self._name: str = ""
        self._text: str = ""  # description
        self._char: str = ""
        self._values: List[str] = ["0", "1"]
        self._index: int = 0
        self._location: str = ""
        self._bool = True  # many options

    def name(self, _name):
        self._name = _name
        return self

    def text(self, _text):
        self._text = _text
        return self

    def char(self, _key):
        self._char = _key
        return self

    def values(self, _values: List[str]):
        self._values = _values
        return self

    def index(self, _index):
        self._index = _index
        return self

    def location(self, value: str):
        self._location = value
        return self

    def get_values(self):
        return self._values

    def toggle(self):
        self._index = (self._index + 1) % len(self._values)
        return self

    def many(self):
        self._bool = False
        return self
    
    def bool(self):
        self._bool = True
        return self
    
    def is_bool(self):
        return self._bool

    def get_location(self) -> str:
        return self._location

    def get_value(self) -> str:
        return self._values[self._index % len(self._values)]
    
    def set_value(self, value: Any):
        for i, v in enumerate(self._values):
            if v == value:
                self._index = i
                break

    def is_true(self):
        return self.get_value() == "1"

    def get_name(self) -> str:
        return self._name

    def get_description(self) -> str:
        return self._text

    def get_char(self) -> str:
        return self._char

    def get_index(self) -> int:
        return self._index
    

class Flags:
    minimum = Flag().name("Mínimo").char("M").values(["0", "1"]).text("Mostra os requisitos mínimos para completar a missão").location("left")
    reward = Flag().name("Recompensa").char("R").values(["0", "1"]).text("Mostra a experiência obtida na tarefa").location("left")
    percent = Flag().name("Percentual").char("P").values(["1", "0"]).text("Mostra valores em porcentagem").location("left")
    admin = Flag().name("Admin").char("A").values(["0", "1"]).text("Mostra todas as missões e grupos").location("left")
    fortune = Flag().name("Fortuna").char("F").values(["0", "1"]).text("Mostra mensagem aleatórias na saída").location("left")
    images = Flag().name("Imagens").char("I").values(["1", "0"]).text("Mostra imagens aleatórias").location("left")
    # links = Flag().name("Links").char("Y").values(["0", "1"]).text("Mostra links remotos e locais das tarefas").location("left")

    config    = Flag().name("Config").char("c").values(["0", "1"]).text("Mostra a barra de flags").location("top")
    skills = Flag().name("Skills").char("i").values(["0", "1"]).text("Mostra a barra de skills").location("top")
    others = Flag().name("Outros").char("o").values(["0", "1"]).text("Mostra opções extras").location("bottom")

class FlagsMan:
    def __init__(self, data: Dict[str, int]):
        self.flags: Dict[str, Flag] = {}
        self.top: List[Flag] = []
        self.left: List[Flag] = []
        self.others: List[Flag] = []

        for varname, flag in Flags.__dict__.items():
            if isinstance(flag, Flag):
                self.flags[varname] = flag
                if flag.get_location() == "top":
                    self.top.append(flag)
                elif flag.get_location() == "left":
                    self.left.append(flag)
                else:
                    self.others.append(flag)

        for key, _index in data.items():
            if key in self.flags:
                self.flags[key].index(_index)

    def get_data(self) -> Dict[str, int]:
        data = {}
        for name, flag in self.flags.items():
            if flag.get_location() == "geral":
                continue
            if len(flag.get_values()) > 1:
                data[name] = flag.get_index()
        return data


class __Symbols:
    def __init__(self):
        self.downloaded = Token()
        self.opening = Token()
        self.neutral = Token()
        self.success = Token()
        self.failure = Token()
        self.wrong = Token()
        self.compilation = Token()
        self.execution = Token()
        self.unequal = Token()
        self.equalbar = Token()
        self.hbar = Token()
        self.vbar = Token()
        self.whitespace = Token()  # interpunct
        self.newline = Token()  # carriage return
        self.cfill = Token()
        self.tab = Token()
        self.arrow_up = Token()
        self.check = Token()  
        self.uncheck = Token()
        self.opcheck = Token()
        self.opuncheck = Token()

        self.ascii = False
        self.set_unicode()

    def get_mode(self) -> str:
        return "ASCII" if self.ascii else "UTF-8"

    def set_ascii(self):
        self.ascii = True
        self.downloaded = Token("⇓")
        self.opening = Token("=> ")
        self.neutral = Token(".")
        self.success = Token("S")
        self.failure = Token("X")
        self.wrong = Token("W")
        self.compilation = Token("C")
        self.execution = Token("E")
        self.unequal = Token("#")
        self.equalbar = Token("|")
        self.hbar = Token("─")
        self.vbar = Token("│")
        self.whitespace = Token("\u2E31")  # interpunct
        self.newline = Token("▒")#Token("\u21B5")  # carriage return
        self.cfill = Token("_")
        self.tab = Token("    ")
        self.arrow_up = Token("A")

        self.check = Token("x")
        self.uncheck = Token(".")
        self.opcheck = Token("█")
        self.opuncheck = Token("▒")

    def set_unicode(self):
        self.ascii = False

        self.downloaded = Token("▼")
        self.to_download = Token("▽")
        self.cant_download = Token("◉")
        self.opening = Token("=> ")
        self.neutral = Token("»")
        self.success = Token("✓")
        self.failure = Token("✗")
        self.wrong = Token("ω")
        self.compilation = Token("ϲ")
        self.execution = Token("ϵ")
        self.unequal = Token("├")
        self.equalbar = Token("│")
        self.hbar = Token("─")
        self.vbar = Token("│")

        self.whitespace = Token("·")
        # self.whitespace = Token("␣")
        
        # self.newline = Token("¶")
        self.newline = Token("↲")
        # self.newline = Token("⏎")

        self.cfill = Token("_")
        self.tab = Token("    ")
        self.arrow_up = Token("↑")

        self.check = Token("✓")
        self.uncheck = Token("✗")
        self.opcheck = Token("ⴲ")
        self.opuncheck = Token("ⵔ")


    def set_colors(self):
        self.opening.fmt = "b"
        self.neutral.fmt = "b"
        self.success.fmt = "g"
        self.failure.fmt = "r"
        self.wrong.fmt = "r"
        self.compilation.fmt = "y"
        self.execution.fmt = "y"
        self.unequal.fmt = "r"
        self.equalbar.fmt = "g"


symbols = __Symbols()


class Task:

    def __init__(self):
        self.line_number = 0
        self.line = ""
        self.key = ""

        self.grade: int = 0 #valor de 0 a 10
        self.test_progress: int = 0 #valor de 0 a 100
        self.main_index: int = 0

        self.qskills: Dict[str, int] = {} # default quest skills
        self.skills: Dict[str, int] = {} # local skills
        self.xp: int = 0
        
        self.opt: bool = False
        self.title = ""
        self.link = ""

        self.default_min_value = 7 # default min grade to complete task

    def load_from_db(self, value: str):
        if ":" not in value:
            self.grade = int(value)
        else:
            v = value.split(":")
            if len(v) == 3:
                self.grade = int(v[0])
                self.main_index = int(v[1])
                self.test_progress = int(v[2])

    def save_to_db(self) -> str:
        return f"{self.grade}:{self.main_index}:{self.test_progress}"
    
    def is_db_empty(self) -> bool:
        return self.grade == 0 and self.main_index == 0 and self.test_progress == 0

    def get_grade_color(self, min_value: Optional[int] = None) -> str:
        if min_value is None:
            min_value = self.default_min_value
        if self.grade == 0:
            return "m"
        if self.grade < min_value:
            return "r"
        if self.grade < 10:
            return "y"
        if self.grade == 10:
            return "g"
        return "w"  

    def get_grade_symbol(self, min_value: Optional[int] = None) -> Sentence:
        
        if min_value is None:
            min_value = self.default_min_value
        color = self.get_grade_color(min_value)
        if self.grade == 0:
            return Sentence().addf(color, symbols.uncheck.text)
        if self.grade < min_value:
            return Sentence().addf(color, str(self.grade))
        if self.grade < 10:
            return Sentence().addf(color, str(self.grade))
        if self.grade == 10:
            return Sentence().addf(color, symbols.check.text)
        return Sentence().add("0")

    def get_percent(self):
        if self.grade == 0:
            return 0
        if self.grade == 10:
            return 100
        return self.grade * 10
    
    def is_complete(self):
        return self.grade == 10

    def not_started(self):
        return self.grade == 0
    
    def in_progress(self):
        return self.grade > 0 and self.grade < 10

    def set_grade(self, grade: int):
        grade = int(grade)
        if grade >= 0 and grade <= 10:
            self.grade = grade
        else:
            print(f"Grade inválida: {grade}")
    
    def process_link(self, base_file):
        if self.link.startswith("http"):
            return
        if self.link.startswith("./"):
            self.link = self.link[2:]
        # todo trocar / por \\ se windows
        self.link = base_file + self.link

    def __str__(self):
        line = str(self.line_number).rjust(3)
        key = "" if self.key == self.title else self.key + " "
        return f"{line}    {self.grade} {key}{self.title} {self.skills} {self.link}"
    
    def is_downloadable(self):
        return f"@{self.key}" in self.title
    
    def is_downloaded_for_lang(self, rep_dir: str, lang: str) -> bool:
        folder = os.path.join(rep_dir, self.key)
        if not os.path.isfile(os.path.join(folder, "Readme.md")):
            return False
        files = os.listdir(folder)
        if not any([f.endswith("." + lang) for f in files]):
            return False
        return True

class TaskParser:

    @staticmethod
    def load_html_tags(task: Task):                   
        pattern = r"<!--\s*(.*?)\s*-->"
        match = re.search(pattern, task.line)
        if not match:
            return

        tags_raw = match.group(1).strip()
        tags = [tag.strip() for tag in tags_raw.split(" ")]
        task.opt = "opt" in tags
        for t in tags:
            if t.startswith("+"):
                key, value = t[1:].split(":")
                task.skills[key] = int(value)
            elif t.startswith("@"):
                task.key = t[1:]

    @staticmethod
    def parse_item_with_link(line) -> Tuple[bool, str, str]:
        pattern = r"\ *-.*\[(.*?)\]\((.+?)\)"
        match = re.match(pattern, line)
        if match:
            return True, match.group(1), match.group(2)
        return False, "", ""
    
    @staticmethod
    def parse_task_with_link(line) -> Tuple[bool, str, str]:
        pattern = r"\ *- \[ \].*\[(.*?)\]\((.+?)\)"
        match = re.match(pattern, line)
        if match:
            return True, match.group(1), match.group(2)
        return False, "", ""

    @staticmethod
    def parse_arroba_from_title_link(titulo, link) -> Tuple[bool, str]:
        pattern = r'@\w+'
        match = re.search(pattern, titulo)
        if not match:
            return False, ""
        key = match.group(0)[1:]
        if not (key + "/Readme.md") in link:
            return False, ""
        return True, key

    # - [Titulo com @palavra em algum lugar](link/@palavra/Readme.md) <!-- tag1 tag2 tag3 -->
    @staticmethod
    def __parse_coding_task(line, line_num) -> Optional[Task]:
        if line == "":
            return None
        line = line.lstrip()

        found, titulo, link = TaskParser.parse_item_with_link(line)
        if not found:
            return None
        found, key = TaskParser.parse_arroba_from_title_link(titulo, link)
        if not found:
            return None

        task = Task()

        task.line = line
        task.line_number = line_num
        task.key = key
        task.title = titulo
        task.link = link
        TaskParser.load_html_tags(task)

        return task

    # se com - [ ], não precisa das tags dentro do html, o key será dado pelo título
    # se tiver as tags dentro do html, se alguma começar com @, o key será dado por ela
    # - [ ] [Título](link)
    # - [ ] [Título](link) <!-- tag1 tag2 tag3 -->
    # - [Título](link) <!-- tag1 tag2 tag3 -->
    @staticmethod
    def __parse_reading_task(line, line_num) -> Optional[Task]:
        if line == "":
            return None
        line = line.lstrip()

        found, titulo, link = TaskParser.parse_task_with_link(line)

        if found:
            task = Task()
            task.key = link
            task.title = titulo
            task.link = link
            task.line = line
            task.line_number = line_num
            TaskParser.load_html_tags(task)
            return task
        
        task = Task()
        found, titulo, link = TaskParser.parse_item_with_link(line)
        task.key = ""
        if found:
            task.link = link
            task.line = line
            task.line_number = line_num
            TaskParser.load_html_tags(task)
            if task.key == "": # item with links needs a key
                return None
            task.title = titulo
            return task

        return None

    @staticmethod
    def parse_line(line, line_num) -> Optional[Task]:
        task = TaskParser.__parse_coding_task(line, line_num)
        
        if task is not None:
            return task
        task = TaskParser.__parse_reading_task(line, line_num)
        if task is not None:
            return task
        return None



class Quest:
    def __init__(self):
        self.line_number = 0
        self.line = ""
        self.key = ""
        self.title = ""
        self.__tasks: List[Task] = []
        self.skills: Dict[str, int] = {}  # s:skill
        self.cluster = ""
        self.requires = []  # r:quest_key
        self.requires_ptr = []
        self.opt = False  # opt
        self.qmin: Optional[int] = None  # q:  minimo de 50 porcento da pontuação total para completar
        self.tmin: Optional[int] = None  # t: ou ter no mínimo esse valor de todas as tarefas
        self.filename = ""
        self.__is_reachable: bool = False
        
    def is_reachable(self)-> bool:
        return self.__is_reachable

    def set_reachable(self, value: bool):
        self.__is_reachable = value

    def __str__(self):
        line = str(self.line_number).rjust(3)
        tasks_size = str(len(self.__tasks)).rjust(2, "0")
        key = "" if self.key == self.title else self.key + " "
        output = f"{line} {tasks_size} {key}{self.title} {self.skills} {self.requires}"
        return output

    def get_resume_by_percent(self) -> Sentence:
        value = self.get_percent()
        return Sentence().addf(self.get_grade_color(), (str(value) + "%").rjust(4))
    
    def get_requirement(self) -> Sentence:
        if self.qmin is not None:
            return Sentence().addf("y", f"[{self.qmin}%]")
        if self.tmin is not None:
            return Sentence().addf("y", f"[t>{self.tmin - 1}]")
        return Sentence()

    def get_resume_by_tasks(self) -> Sentence:
        tmin = self.tmin if self.tmin is not None else 7
        total = len([t for t in self.__tasks if not t.opt])
        plus = len([t for t in self.__tasks if t.opt])
        count = len([t for t in self.__tasks if t.grade >= tmin])
        output = f"{count}/{total}"
        if plus > 0:
            output += f"+{plus}"
        return Sentence().addf(self.get_grade_color(), "(" + output + ")")

    def get_grade_color(self) -> str:
        if self.not_started():
            return "m"
        if not self.is_complete():
            return "r"
        if self.get_percent() == 100:
            return "g"
        return "y"

    def is_complete(self):
        if self.qmin is not None:
            return self.get_percent() >= self.qmin
        # task complete mode
        if self.tmin is not None:
            for t in self.__tasks:
                if not t.opt and t.grade < self.tmin:
                    return False
        return True

    def add_task(self, task: Task, filename: str):
        if self.qmin is not None:
            if task.opt:
                print(f"Quests com requerimento de porcentagem não deve ter Tasks opcionais")
                print(f"{filename}:{task.line_number} {task.key}")
                exit(1)
        task.qskills = self.skills

        task.xp = 0
        for s in task.skills:
            task.xp += task.skills[s]

        for s in task.qskills:
            task.xp += task.qskills[s]
        
        self.__tasks.append(task)

    def get_tasks(self):
        return self.__tasks

    def get_xp(self) -> Tuple[int, int]:
        total = 0
        obtained = 0
        for t in self.__tasks:
            total += t.xp
            if t.grade > 0:
                obtained += t.xp * t.grade // 10

        return obtained, total
        
    def get_percent(self):
        obtained, total = self.get_xp()
        if total == 0:
            return 0
        return obtained * 100 // total

    def in_progress(self):
        if self.is_complete():
            return False
        for t in self.__tasks:
            if t.grade != 0:
                return True
        return False

    def not_started(self):
        if self.is_complete():
            return False
        if self.in_progress():
            return False
        return True




class QuestParser:
    quest: Quest

    def __init__(self):
        self.quest = Quest()
        self.line = ""
        self.line_num = 0
        self.default_qmin_requirement = 50
        self.default_task_xp = 10
        self.filename = ""

    def finish_quest(self) -> Quest:

        if self.quest.key == "":
            self.quest.key = get_md_link(self.quest.title)

        if len(self.quest.skills) == 0:
            self.quest.skills["xp"] = self.default_task_xp
        
        if self.quest.qmin is None and self.quest.tmin is None:
            self.quest.qmin = self.default_qmin_requirement

        return self.quest

    def match_full_pattern(self):
        fullpattern = r"^#+\s*(.*?)<!--\s*(.*?)\s*-->.*$"
        match = re.match(fullpattern, self.line)

        if not match:
            return False
        self.quest.title = match.group(1).strip()
        tags_raw = match.group(2).strip()
        tags = [tag.strip() for tag in tags_raw.split()]

        # key
        keys = [t[1:] for t in tags if t.startswith("@")]
        if len(keys) > 0:
            self.quest.key = keys[0]

        # skills
        skills = [t[1:] for t in tags if t.startswith("+")]
        if len(skills) > 0:
            self.quest.skills = {}
            for s in skills:
                k, v = s.split(":")
                self.quest.skills[k] = int(v)
        # requires
        self.quest.requires = [t[2:] for t in tags if t.startswith("r:")]

        self.quest.opt = "opt" in tags
        # type
        # try:
        #     self.quest.type = [t[1:] for t in tags if t.startswith("#")][0]
        # except:
        #     self.quest.type = "main"
        
        # quest percent
        qmin = [t[2:] for t in tags if t.startswith("q:")]
        
        if len(qmin) > 0:
            self.quest.qmin = int(qmin[0])

        # task min value requirement
        tmin = [t[2:] for t in tags if t.startswith("t:")]
        if len(tmin) > 0:
            self.quest.tmin = int(tmin[0])
            if self.quest.tmin > 10:
                print("fail: tmin > 10")
                exit(1)
        return True

    def __match_minimal_pattern(self):
        minipattern = r"^#+\s*(.*?)\s*$"
        match = re.match(minipattern, self.line)
        if match:
            self.quest.title = match.group(1).strip()
            return True
        return False

    def parse_quest(self, filename, line, line_num) -> Optional[Quest]:
        self.line = line
        self.line_num = line_num
        self.filename = filename

        self.quest.line = self.line
        self.quest.line_number = self.line_num
        self.quest.cluster = ""

        if self.match_full_pattern():
            return self.finish_quest()
        
        if self.__match_minimal_pattern():
            return self.finish_quest()
        
        return None



class Cluster:
    def __init__(self, line_number: int = 0, title: str = "", key: str = "", color: Optional[str] = None):
        self.line_number = line_number
        self.title: str = title
        self.key: str = key
        self.quests: List[Quest] = []
        self.color: Optional[str] = color
        self.__is_reachable = False

    def is_reachable(self):
        return self.__is_reachable
    
    def set_reachable(self, value: bool):
        self.__is_reachable = value
        return self

    def __str__(self):
        line = str(self.line_number).rjust(3)
        quests_size = str(len(self.quests)).rjust(2, "0")
        key = "" if self.key == self.title else self.key + " "
        return f"{line} {quests_size} {key}{self.title}"
    
    def get_grade_color(self) -> str:
        perc = self.get_percent()
        if perc == 0:
            return "m"
        if perc < 50:
            return "r"
        if perc < 100:
            return "y"
        return "g"

    def get_percent(self):
        total = 0
        for q in self.quests:
            total += q.get_percent()
        return total // len(self.quests)

    def get_resume_by_percent(self) -> Sentence:
        return Sentence().addf(self.get_grade_color(), f"{self.get_percent()}%".rjust(4))

    def get_resume_by_quests(self):
        total = len(self.quests)
        count = len([q for q in self.quests if q.is_complete()])
        return Sentence().addf(self.get_grade_color(), f"({count}/{total})")
        



class ExecutionResult(enum.Enum):
    UNTESTED = "untested_"
    SUCCESS = "correct__"
    WRONG_OUTPUT = "wrong_out"
    COMPILATION_ERROR = "compilati"
    EXECUTION_ERROR = "execution"

    @staticmethod
    def get_symbol(result) -> Token:
        if result == ExecutionResult.UNTESTED:
            return symbols.neutral
        elif result == ExecutionResult.SUCCESS:
            return symbols.success
        elif result == ExecutionResult.WRONG_OUTPUT:
            return symbols.wrong
        elif result == ExecutionResult.COMPILATION_ERROR:
            return symbols.compilation
        elif result == ExecutionResult.EXECUTION_ERROR:
            return symbols.execution
        else:
            raise ValueError("Invalid result type")

    def __str__(self):
        return self.value


class DiffMode(enum.Enum):
    FIRST = "MODE: SHOW FIRST FAILURE ONLY"
    ALL = "MODE: SHOW ALL FAILURES"
    QUIET = "MODE: SHOW NONE FAILURES"


class IdentifierType(enum.Enum):
    OBI = "OBI"
    MD = "MD"
    TIO = "TIO"
    VPL = "VPL"
    SOLVER = "SOLVER"

class Success(enum.Enum):
    RANDOM = "RANDOM"
    FIXED = "FIXED"

class Identifier:
    def __init__(self):
        pass

    @staticmethod
    def get_type(target: str) -> IdentifierType:
        if os.path.isdir(target):
            return IdentifierType.OBI
        elif target.endswith(".md"):
            return IdentifierType.MD
        elif target.endswith(".tio"):
            return IdentifierType.TIO
        elif target.endswith(".vpl"):
            return IdentifierType.VPL
        else:
            return IdentifierType.SOLVER


class Param:

    def __init__(self):
        pass

    class Basic:
        def __init__(self):
            self.index: Optional[int] = None
            self.label_pattern: Optional[str] = None
            self.is_up_down: bool = False
            self.diff_mode = DiffMode.FIRST
            self.filter: bool = False
            self.compact: bool = False

        def set_index(self, value: Optional[int]):
            self.index= value
            return self

        def set_label_pattern(self, label_pattern: Optional[str]):
            self.label_pattern = label_pattern
            return self
        
        def set_compact(self, value: bool):
            self.compact = value
            return self

        def set_up_down(self, value: bool):
            self.is_up_down = value
            return self
    
        def set_filter(self, value: bool):
            self.filter = value
            return self

        def set_diff_mode(self, value: DiffMode):
            self.diff_mode = value
            return self

    class Manip:
        def __init__(self):
            self.unlabel: bool = False
            self.to_sort: bool = False
            self.to_number: bool = False
        
        def set_unlabel(self, value: bool):
            self.unlabel = value
            return self
        
        def set_to_sort(self, value: bool):
            self.to_sort = value
            return self
        
        def set_to_number(self, value: bool):
            self.to_number = value
            return self


class Unit:
    def __init__(self, case: str = "", inp: str = "", outp: str = "", grade: Optional[int] = None, source: str = ""):
        self.source = source  # stores the source file of the unit
        self.source_pad = 0  # stores the pad to justify the source file
        self.case = case  # name
        self.case_pad = 0  # stores the pad to justify the case name
        self.input = inp  # input
        self.output = outp  # expected output
        self.user: Optional[str] = None  # solver generated answer
        self.grade: Optional[int] = grade  # None represents proportional gr, 100 represents all
        self.grade_reduction: int = 0  # if grade is None, this atribute should be filled with the right grade reduction
        self.index = 0
        self.repeated: Optional[int] = None

        self.result: ExecutionResult = ExecutionResult.UNTESTED

    def str(self, pad: bool = True) -> Sentence:
        index = str(self.index).zfill(2)
        grade = str(self.grade_reduction).zfill(3)
        rep = "" if self.repeated is None else " [" + str(self.repeated) + "]"
        op = Sentence() + ExecutionResult.get_symbol(self.result) + " " + self.result.value
        source = os.path.basename(self.source)
        if pad:
            source = self.source.ljust(self.source_pad)
        case = self.case
        if pad:
            case = self.case.ljust(self.case_pad)
        return Sentence() + "(" + op + ")" + f"[{index}] GR:{grade} {source} ({case}){rep}"




class VplParser:
    @staticmethod
    def finish(text):
        return text if text.endswith("\n") else text + "\n"

    @staticmethod
    def unwrap(text):
        while text.endswith("\n"):
            text = text[:-1]
        if text.startswith("\"") and text.endswith("\""):
            text = text[1:-1]
        return VplParser.finish(text)

    @staticmethod
    class CaseData:
        def __init__(self, case="", inp="", outp="", grade: Optional[int] = None):
            self.case: str = case
            self.input: str = VplParser.finish(inp)
            self.output: str = VplParser.unwrap(VplParser.finish(outp))
            self.grade: Optional[int] = grade

        def __str__(self):
            return "case=" + self.case + '\n' \
                   + "input=" + self.input \
                   + "output=" + self.output \
                   + "gr=" + str(self.grade)

    regex_vpl_basic = r"case= *([ \S]*) *\n *input *=(.*?)^ *output *=(.*)"
    regex_vpl_extended = r"case= *([ \S]*) *\n *input *=(.*?)^ *output *=(.*?)^ *grade *reduction *= *(\S*)% *\n?"

    @staticmethod
    def filter_quotes(x):
        return x[1:-2] if x.startswith('"') else x

    @staticmethod
    def split_cases(text: str) -> List[str]:
        regex = r"^ *[Cc]ase *="
        subst = "case="
        text = re.sub(regex, subst, text, 0, re.MULTILINE | re.DOTALL)
        return ["case=" + t for t in text.split("case=")][1:]

    @staticmethod
    def extract_extended(text) -> Optional[CaseData]:
        f = re.match(VplParser.regex_vpl_extended, text, re.MULTILINE | re.DOTALL)
        if f is None:
            return None
        try:
            gr = int(f.group(4))
        except ValueError:
            gr = None
        return VplParser.CaseData(f.group(1), f.group(2), f.group(3), gr)

    @staticmethod
    def extract_basic(text) -> Optional[CaseData]:
        m = re.match(VplParser.regex_vpl_basic, text, re.MULTILINE | re.DOTALL)
        if m is None:
            return None
        return VplParser.CaseData(m.group(1), m.group(2), m.group(3), None)

    @staticmethod
    def parse_vpl(content: str) -> List[CaseData]:
        text_cases = VplParser.split_cases(content)
        seq: List[VplParser.CaseData] = []

        for text in text_cases:
            case = VplParser.extract_extended(text)
            if case is not None:
                seq.append(case)
                continue
            case = VplParser.extract_basic(text)
            if case is not None:
                seq.append(case)
                continue
            print("invalid case: " + text)
            exit(1)
        return seq

    @staticmethod
    def to_vpl(unit: CaseData):
        text = "case=" + unit.case + "\n"
        text += "input=" + unit.input
        text += "output=\"" + unit.output + "\"\n"
        if unit.grade is not None:
            text += "grade reduction=" + str(unit.grade) + "%\n"
        return text


class Loader:
    regex_tio = r"^ *>>>>>>>> *(.*?)\n(.*?)^ *======== *\n(.*?)^ *<<<<<<<< *\n?"

    def __init__(self):
        pass

    @staticmethod
    def parse_cio(text, source):
        unit_list = []
        text = "\n" + text

        pattern = r'```.*?\n(.*?)```'  # get only inside code blocks
        code = re.findall(pattern, text, re.MULTILINE | re.DOTALL)
        # join all code blocks found
        text = "\n" + "\n".join(code)

        pieces = []  # header, input, output

        open_case = False
        for line in text.split("\n"):
            if line.startswith("#__case") or line.startswith("#TEST_CASE"):
                pieces.append({"header": line, "input": [], "output": []})
                open_case = True
            elif open_case:
                pieces[-1]["output"].append(line)
                if line.startswith("$end"):
                    open_case = False

        # concatenando testes contínuos e finalizando testes sem $end
        for i in range(len(pieces)):
            output = pieces[i]["output"]
            if output[-1] != "$end" and i < len(pieces) - 1:
                pieces[i + 1]["output"] = output + pieces[i + 1]["output"]
                output.append("$end")

        # removendo linhas vazias e criando input das linhas com $
        for piece in pieces:
            piece["input"] = [line[1:] for line in piece["output"] if line.startswith("$")]
            piece["output"] = [line for line in piece["output"] if line != "" and not line.startswith("#")]

        for piece in pieces:
            case = " ".join(piece["header"].split(" ")[1:])
            inp = "\n".join(piece["input"]) + "\n"
            output = "\n".join(piece["output"]) + "\n"
            unit_list.append(Unit(case, inp, output, None, source))

        return unit_list

    @staticmethod
    def parse_tio(text: str, source: str = "") -> List[Unit]:

        # identifica se tem grade e retorna case name e grade
        def parse_case_grade(value: str) -> Tuple[str, Optional[int]]:
            if value.endswith("%"):
                words = value.split(" ")
                last = value.split(" ")[-1]
                _case = " ".join(words[:-1])
                grade_str = last[:-1]           # ultima palavra sem %
                try:
                    _grade = int(grade_str)
                    return _case, _grade
                except ValueError:
                    pass
            return value, None

        matches = re.findall(Loader.regex_tio, text, re.MULTILINE | re.DOTALL)
        unit_list = []
        for m in matches:
            case, grade = parse_case_grade(m[0])
            unit_list.append(Unit(case, m[1], m[2], grade, source))
        return unit_list

    @staticmethod
    def parse_vpl(text: str, source: str = "") -> List[Unit]:
        data_list = VplParser.parse_vpl(text)
        output: List[Unit] = []
        for m in data_list:
            output.append(Unit(m.case, m.input, m.output, m.grade, source))
        return output

    @staticmethod
    def parse_dir(folder) -> List[Unit]:
        pattern_loader = PatternLoader()
        files = sorted(os.listdir(folder))
        matches = pattern_loader.get_file_sources(files)

        unit_list: List[Unit] = []
        try:
            for m in matches:
                unit = Unit()
                unit.source = os.path.join(folder, m.label)
                unit.grade = 100
                with open(os.path.join(folder, m.input_file)) as f:
                    value = f.read()
                    unit.input = value + ("" if value.endswith("\n") else "\n")
                with open(os.path.join(folder, m.output_file)) as f:
                    value = f.read()
                    unit.output = value + ("" if value.endswith("\n") else "\n")
                unit_list.append(unit)
        except FileNotFoundError as e:
            print(str(e))
        return unit_list

    @staticmethod
    def parse_source(source: str) -> List[Unit]:
        if os.path.isdir(source):
            return Loader.parse_dir(source)
        if os.path.isfile(source):
            #  if PreScript.exists():
            #      source = PreScript.process_source(source)
            with open(source, encoding="utf-8") as f:
                content = f.read()
            if source.endswith(".vpl"):
                return Loader.parse_vpl(content, source)
            elif source.endswith(".tio"):
                return Loader.parse_tio(content, source)
            elif source.endswith(".md"):
                tests = Loader.parse_tio(content, source)
                tests += Loader.parse_cio(content, source)
                return tests
            else:
                print("warning: target format do not supported: " + source)  # make this a raise
        else:
            raise FileNotFoundError('warning: unable to find: ' + source)
        return []




class Writer:

    def __init__(self):
        pass

    @staticmethod
    def to_vpl(unit: Unit):
        text = "case=" + unit.case + "\n"
        text += "input=" + unit.input
        text += "output=\"" + unit.output + "\"\n"
        if unit.grade is None:
            text += "\n"
        else:
            text += "grade reduction=" + str(unit.grade).zfill(3) + "%\n"
        return text

    @staticmethod
    def to_tio(unit: Unit):
        text = ">>>>>>>>"
        if unit.case != '':
            text += " " + unit.case
        if unit.grade is not None:
            text += " " + str(unit.grade) + "%"
        text += '\n' + unit.input
        text += "========\n"
        text += unit.output
        if unit.output != '' and unit.output[-1] != '\n':
            text += '\n'
        text += "<<<<<<<<\n"
        return text

    @staticmethod
    def save_dir_files(folder: str, pattern_loader: PatternLoader, label: str, unit: Unit) -> None:
        file_source = pattern_loader.make_file_source(label)
        with open(os.path.join(folder, file_source.input_file), "w") as f:
            f.write(unit.input)
        with open(os.path.join(folder, file_source.output_file), "w") as f:
            f.write(unit.output)

    @staticmethod
    def save_target(target: str, unit_list: List[Unit], force: bool = False):
        def ask_overwrite(file):
            print("file " + file + " found. Overwrite? (y/n):")
            resp = input()
            if resp.lower() == 'y':
                print("overwrite allowed")
                return True
            print("overwrite denied\n")
            return False

        def save_dir(_target: str, _unit_list):
            folder = _target
            pattern_loader = PatternLoader()
            number = 0
            for unit in _unit_list:
                Writer.save_dir_files(folder, pattern_loader, str(number).zfill(2), unit)
                number += 1

        def save_file(_target, _unit_list):
            if _target.endswith(".tio"):
                _new = "\n".join([Writer.to_tio(unit) for unit in _unit_list])
            else:
                _new = "\n".join([Writer.to_vpl(unit) for unit in _unit_list])

            file_exists = os.path.isfile(_target)

            if file_exists:
                _old = open(_target).read()
                if _old == _new:
                    print("no changes in test file")
                    return

            if not file_exists or (file_exists and (force or ask_overwrite(_target))):
                with open(_target, "w") as f:
                    f.write(_new)

                    if not force:
                        print("file " + _target + " wrote")

        target_type = Identifier.get_type(target)
        if target_type == IdentifierType.OBI:
            save_dir(target, unit_list)
        elif target_type == IdentifierType.TIO or target_type == IdentifierType.VPL:
            save_file(target, unit_list)
        else:
            print("fail: target " + target + " do not supported for build operation\n")


class Color:
    enabled = True
    terminal_styles = {
        '.': '\033[0m', # Reset
        '*': '\033[1m', # Bold
        '/': '\033[3m', # Italic
        '_': '\033[4m', # Underline
        
        'k': '\033[30m', # Black
        'r': '\033[31m', # Red
        'g': '\033[32m', # Green
        'y': '\033[33m', # Yellow
        'b': '\033[34m', # Blue
        'm': '\033[35m', # Magenta
        'c': '\033[36m', # Cyan
        'w': '\033[37m', # White


        'K': '\033[40m', # Background black
        'W': '\033[47m', # Background white
    }

def _colour(modifiers: str, text: str) -> str:
    if not Color.enabled:
        return text
    output = ''
    for m in modifiers:
        val = Color.terminal_styles.get(m, '')
        if val != '':
            output += val
    output += text + Color.terminal_styles.get('.', "")
    return output

def term_colour(ftext: Sentence) -> str:
    output = ""
    for token in ftext.data:
        output += _colour(token.fmt, token.text)
    return output

def term_print(ftext: Union[str, Sentence], **kwargs):
    if isinstance(ftext, str):
        print(ftext, **kwargs)
    else:
        print(term_colour(ftext), **kwargs)

def singleton(class_):
    instances = {}
    def getinstance(*args, **kwargs):
        if class_ not in instances:
            instances[class_] = class_(*args, **kwargs)
        return instances[class_]
    return getinstance

@singleton
class Settings:
    def __init__(self):
        self.reps: Dict[str, RepSource] = {}
        self.app = AppSettings()
        self.settings_file = ""

    def set_settings_file(self, path: str):
        self.settings_file = path
        return self

    def get_settings_file(self) -> str:
        if self.settings_file is None or self.settings_file == "":
            self.package_name = "tko"
            default_filename = "settings.json"
            self.settings_file = os.path.abspath(default_filename)  # backup for replit, dont remove
        
        if not os.path.exists(self.settings_file):
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)
        return self.settings_file

    def reset(self):
        self.reps = {}
        self.reps["fup"] = RepSource(url = "https://github.com/qxcodefup/arcade/blob/master/Readme.md")
        self.reps["ed"] = RepSource(url = "https://github.com/qxcodeed/arcade/blob/master/Readme.md")
        self.reps["poo"] = RepSource(url = "https://github.com/qxcodepoo/arcade/blob/master/Readme.md")

        # for key in self.reps:
        #     repdata = self.get_rep_data(key)
        #     repdata.save_data_to_json()

        self.app = AppSettings()
        return self

    def __get_rep_file_path(self, course: str) -> str:
        return os.path.join(self.app.get_rootdir(), course, ".rep.json")   

    def get_rep_source(self, course: str) -> RepSource:
        if course in self.reps:
            return self.reps[course]
        raise Warning(f"Curso {course} não encontrado")

    def get_rep_data(self, course: str) -> RepData:
        cfg_file = self.__get_rep_file_path(course)
        rep_data = RepData(cfg_file)
        if os.path.exists(cfg_file):
            return rep_data.load_data_from_json()
        return rep_data.load_defaults()
  
    # def to_dict(self) -> Dict[str, Any]:
    #     return {
    #         "reps": {k: v.to_dict() for k, v in self.reps.items()},
    #         "geral": self.app.to_dict()
    #     }
    
    def load_settings(self):
        try:
            settings_file = self.get_settings_file() # assure right loading if value == ""
            with open(settings_file, "r", encoding="utf-8") as f:
                data = json.load(f)
                self.reps = {k: RepSource().from_dict(v) for k, v in data.get("reps", {}).items()}
                self.app = AppSettings().from_dict(data.get("geral", {}))
        except (FileNotFoundError, json.decoder.JSONDecodeError) as _e:
            self.reset()
            self.save_settings()
        return self

    # def from_dict(self, data: Dict[str, Any]):
    #     self.reps = {k: RepSource().from_dict(v) for k, v in data.get("reps", {}).items()}
    #     self.app = AppSettings().from_dict(data.get("geral", {}))
    #     return self

    def check_rootdir(self) -> None:
        if self.app.get_rootdir() != "":
            return
        term_print(Sentence().add("Pasta padrão para download de arquivos ").addf("r", "precisa").add(" ser definida."))
        term_print(Sentence().add("Escolha ").addf("r", "uma").add(" para continuar:"))
        here_cwd = os.getcwd()
        qxcode = os.path.join(os.path.expanduser("~"), "qxcode")

        while True:
            term_print(Sentence().addf("r", "1 - ").add(here_cwd))
            term_print(Sentence().addf("r", "2 - ").add(qxcode))
            term_print(Sentence().addf("r", "3 - ").add("Outra pasta"))
            term_print(Sentence().add("Default ").addf("r", "1").add(": "), end="")
            op = input()
            if op == "":
                op = "1"
            if op == "1":
                home_qxcode = here_cwd
                break
            if op == "2":
                home_qxcode = qxcode
                break
            if op == "3":
                term_print(Sentence().addf("y", "Navegue até o diretório desejado e execute o tko novamente."))
                exit(1)

        if not os.path.exists(home_qxcode):
            os.makedirs(home_qxcode)
        print("Pasta padrão para download de arquivos foi definida em: " + home_qxcode)
        print("Você pode alterar, navegando até a a pasta desejada e executando o comando")
        print("tko config --root .")
        self.app.set_rootdir(home_qxcode)
        self.save_settings();
    
    def save_settings(self):
        file = self.get_settings_file()
        value = {
            "reps": {k: v.to_dict() for k, v in self.reps.items()},
            "geral": self.app.to_dict()
        }
        with open(file, "w", encoding="utf-8") as f:
            json.dump(value, f, indent=4)
        return self

    def __str__(self):
        output = ["Repositories:"]
        maxlen = max([len(key) for key in self.reps])
        for key in self.reps:
            prefix = f"- {key.ljust(maxlen)}"
            if self.reps[key].file and self.reps[key].url:
                output.append(f"{prefix} : dual   : {self.reps[key].url} ; {self.reps[key].file}")
            elif self.reps[key].url:
                output.append(f"{prefix} : remote : {self.reps[key].url}")
            else:
                output.append(f"{prefix} : local  : {self.reps[key].file}")
        return "\n".join(output)


class Style:

    @staticmethod
    def has_borders():
        return Settings().app.is_nerdfonts()
    
    @staticmethod
    def has_colors():
        return Settings().app.is_colored()

    @staticmethod
    def border_round(color: str, data: str):
        return Sentence().addf(color.lower(), Style.roundL()).addf(color, data).addf(color.lower(), Style.roundR())

    @staticmethod
    def border_sharp(color: str, data: str):
        return Sentence().addf(color.lower(), Style.sharpL()).addf(color, data).addf(color.lower(), Style.sharpR())

    @staticmethod
    def roundL():
        return "" if Style.has_borders() else "█"

    @staticmethod
    def roundR():
        return "" if Style.has_borders() else "█"

    @staticmethod
    def sharpL():
        return "" if Style.has_borders() else "█"

    @staticmethod
    def sharpR():
        return "" if Style.has_borders() else "█"
    
    @staticmethod
    def midL():
        return "" if Style.has_borders() else "█"
    
    @staticmethod
    def midR():
        return "" if Style.has_borders() else "█"
 
    @staticmethod
    def focus():
        return "W" if not Style.has_colors() else "B"
    @staticmethod
    def prog_done():
        return "g" if not Style.has_colors() else "g"
    @staticmethod
    def prog_todo():
        return "" if not Style.has_colors() else "y"
    @staticmethod
    def flag_on():
        return "W" if not Style.has_colors() else "G"
    @staticmethod
    def flag_off():
        return "W" if not Style.has_colors() else "Y"
    # @staticmethod
    # def cmds():
    #     return "W" if Flags.mono.is_true() else "B"
    @staticmethod
    def skill_done():
        return "kW" if not Style.has_colors() else "C"
    @staticmethod
    def skill_todo():
        return "wK" if not Style.has_colors() else "M"
    @staticmethod
    def main_done():
        return "kW" if not Style.has_colors() else "G"
    @staticmethod
    def main_todo():
        return "wK" if not Style.has_colors() else "R"
    
    @staticmethod
    def skills():
        return "c"

    @staticmethod
    def new():
        return "g"

    nothing = "m"
    started = "r"
    required = "y"
    complete = "g"

    shell = "r" # extern shell cmds
    htext = ""
    check = "g"
    uncheck = "y"
    param = "c"

    @staticmethod
    def build_bar(text: str, percent: float, length: int, fmt_true: str = "/kC",
                  fmt_false: str = "/kY", round=True) -> Sentence:
        if round and (len(text) >= length - 2):
            text = " " + text

        if length > len(text):
            prefix = (length - len(text)) // 2
            suffix = length - len(text) - prefix
            text = " " * prefix + text + " " * suffix
        elif length < len(text):
            text = text[:length]
        
        full_line = text
        done_len = int(percent * length)
        xp_bar = Token(full_line[:done_len], fmt_true) + Token(full_line[done_len:], fmt_false)
            
        if round:
            xp_bar.data[0].text = Style.roundL()
            fmt = xp_bar.data[0].fmt
            fmt = [c for c in fmt if c.isupper()]
            fmt = "" if len(fmt) == 0 else fmt[0]
            xp_bar.data[0].fmt = fmt.lower()

            xp_bar.data[-1].text = Style.roundR()
            fmt = xp_bar.data[-1].fmt
            fmt = [c for c in fmt if c.isupper()]
            fmt = "" if len(fmt) == 0 else fmt[0]
            xp_bar.data[-1].fmt = fmt.lower()
        return xp_bar

    @staticmethod
    def get_flag_sentence(flag: Flag, pad: int = 0) -> Sentence:
        if not flag.is_bool():
            name = Sentence().addf(flag.get_value(), f"{flag._name}".ljust(pad))
            value = Sentence().add(f"[{flag.get_char()}]").add(name).add(f"{flag.get_value()}".rjust(2))
            return value
            
        char = flag.get_char()
        text = flag.get_name()
        color = "G" if flag.is_true() else "Y"
        textc = ""
        extra = Sentence()
        if not Style.has_colors():
            color = "W" if flag.is_true() else "K"
            textc = "k" if flag.is_true() else "w"
        if pad > 0:
            extra.addf(color, (pad - len(text)) * " ")
        mid = Sentence().addf(color + textc, text).add(extra).addf(color, f"[{char}]")
        # if flag.is_true():
        #     middle = Sentence().addf(color.lower(), Style.roundL()).add(mid).addf(color.lower(), Style.roundR())
        # else:
        middle = Sentence().addf(color.lower(), Style.sharpL()).add(mid).addf(color.lower(), Style.sharpR())
        return middle

class Fmt:
    __scr = None
    # Definindo constantes para as cores
    color_pairs: Dict[str, int] = {}

    COLOR_MAP = {
        'k': curses.COLOR_BLACK,
        'r': curses.COLOR_RED,
        'g': curses.COLOR_GREEN,
        'y': curses.COLOR_YELLOW,
        'b': curses.COLOR_BLUE,
        'm': curses.COLOR_MAGENTA,
        'c': curses.COLOR_CYAN,
        'w': curses.COLOR_WHITE,
    }
    @staticmethod
    def set_scr(scr):
        Fmt.__scr = scr
        Fmt.init_colors()

    @staticmethod
    def init_colors():
        pair_number = 1
        curses.start_color()
        curses.use_default_colors()
        for fk, fg in Fmt.COLOR_MAP.items():
            curses.init_pair(pair_number, fg, -1)
            Fmt.color_pairs[fk] = pair_number
            pair_number += 1

        for fk, fg in Fmt.COLOR_MAP.items():
            for bk, bg in Fmt.COLOR_MAP.items():
                curses.init_pair(pair_number, fg, bg)
                Fmt.color_pairs[fk + bk.upper()] = pair_number
                pair_number += 1

    @staticmethod
    def stroke(y: int, x: int, fmt: str, text: str):
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        stdscr = Fmt.__scr
        italic = False
        underline = False
        source_fmt = fmt
        if "/" in fmt:
            italic = True
            fmt = fmt.replace("/", "")
        if "_" in fmt:
            underline = True
            fmt = fmt.replace("_", "")

        fg_list = [c for c in fmt if c.islower()]
        bg_list = [c for c in fmt if c.isupper()]
        bg = "" if len(bg_list) == 0 else bg_list[0]
        fg = "" if len(fg_list) == 0 else fg_list[0]

        if bg != "" and fg == "":
            fg = "k"
        if fg == "" and bg == "":
            pair_number = -1
        else:
            try:
                pair_number = Fmt.color_pairs[fg + bg]
            except KeyError:
                # print("Cor não encontrada: " + fg + bg)
                raise(Exception("Cor não encontrada: " + source_fmt))
                exit(1)
        if italic:
            stdscr.attron(curses.A_ITALIC)
        if underline:
            stdscr.attron(curses.A_UNDERLINE)
        # Exibir o texto com a combinação de cores escolhida
        if pair_number != -1:
            stdscr.attron(curses.color_pair(pair_number))
        try:
            stdscr.addstr(y, x, text)
        except curses.error as _e:
            lines, cols = Fmt.get_size()
            if y == lines - 1:
                if x + len(text) <= cols:
                    pass
            # lines, cols = stdscr.getmaxyx()
            # stdscr.addstr(10, 10, f"y:{y}, x:{x}, fmt:{fmt}, len:{len(text)} lines:{lines}, cols:{cols}")
            # stdscr.addstr(1, 0, text)
            # raise Exception(f"y:{y}, x:{x}, fmt:{fmt}, len:{len(text)} lines:{lines}, cols:{cols}\n{text}")
        if pair_number != -1:
            stdscr.attroff(curses.color_pair(pair_number))
        if italic:
            stdscr.attroff(curses.A_ITALIC)
        if underline:
            stdscr.attroff(curses.A_UNDERLINE)

    @staticmethod
    def write(y: int, x: int, sentence: Sentence):

        # Escreve um texto na tela com cores diferentes
        lines, cols = Fmt.get_size()
        if y < 0 or y >= lines:
            return
        for token in sentence.resume():
            fmt = token.fmt
            text = token.text
            if x < 0:
                if x + len(text) >= 0:
                    text = text[-x:]
                    x = 0
            if x < cols:
                if x + len(text) >= cols:
                    text = text[:cols - x]
                Fmt.stroke(y, x, fmt, text)
            x += len(text)  # Move a posição x para a direita após o texto

    @staticmethod
    def write_text(y: int, x: int, text: str):
        Fmt.write(y, x, Sentence().add(text))

    @staticmethod
    def debug(y, x, text: Sentence):
        Fmt.write(y, x, text)
        Fmt.getch()


    # @staticmethod
    # def get_user_input(stdscr, prompt: str) -> str:
    #     lines, cols = stdscr.getmaxyx()
    #     curses.echo()  # Ativa a exibição dos caracteres digitados
    #     curses.curs_set(1)  # Ativa o cursor
    #     stdscr.addstr(0, 0, cols * " ")
    #     stdscr.addstr(0, 0, prompt)
    #     stdscr.refresh()
    #     input_str = stdscr.getstr(0, len(prompt), 20).decode('utf-8')  # Captura o input do usuário
    #     curses.noecho()  # Desativa a exibição dos caracteres digitados
    #     curses.curs_set(0)
    #     return input_str

    @staticmethod
    def get_percent(value, pad = 0) -> Sentence:
        text = f"{str(value)}%".rjust(pad)
        if value == 100:
            return Sentence().addf(Style.complete, "100%")
        if value >= 70:
            return Sentence().addf(Style.required, text)
        if value == 0:
            return Sentence().addf(Style.nothing, text)
        return Sentence().addf(Style.started, text)
    
    @staticmethod
    def getch():
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        return Fmt.__scr.getch()

    @staticmethod
    def clear():
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        Fmt.__scr.erase()

    @staticmethod
    def refresh():
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        Fmt.__scr.refresh()

    @staticmethod
    def get_size() -> Tuple[int, int]:
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        return Fmt.__scr.getmaxyx()
        



class Frame:
    def __init__(self, y: int = 0, x: int = 0):
        self._x = x
        self._y = y
        self._inner_dx = 0
        self._inner_dy = 0
        self._border = "rounded"
        self._filled = False
        self._header: Sentence = Sentence()
        self._halign = ""
        self._hprefix = ""
        self._hsuffix = ""
        self._footer: Sentence = Sentence()
        self._falign = ""
        self._fprefix = ""
        self._fsuffix = ""
        self._fill_char = " "
        self._wrap = False
        self._border_color = ""
        self._print_index = 0

    def set_border_color(self, color: str):
        self._border_color = color
        return self

    def get_dx(self):
        return self._inner_dx

    def get_dy(self):
        return self._inner_dy

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y

    def __align_header_footer(self, data, symbol, prefix, suffix):
        dx = self._inner_dx
        color = self._border_color
        pad = dx - len(prefix) - len(suffix)
        hor = self.get_symbol("h")
        
        data.trim_end(pad)
        sent = Sentence().addf(color, prefix).add(data).addf(color, suffix)
        if symbol == "<":
            sent.ljust(dx, Token(hor, color))
        elif symbol == ">":
            sent.rjust(dx, Token(hor, color))
        else:
            sent.center(dx, Token(hor, color))
        return sent

    def get_header(self):
        return Sentence().add(self._hprefix).add(self._header).add(self._hsuffix)
    
    def get_footer(self):
        return Sentence().add(self._fprefix).add(self._footer).add(self._fsuffix)

    def get_full_header(self):
        return self.__align_header_footer(self._header, self._halign, self._hprefix, self._hsuffix)

    def get_full_footer(self):
        return self.__align_header_footer(self._footer, self._falign, self._fprefix, self._fsuffix)

    def set_pos(self, y: int, x: int):
        self._x = x
        self._y = y
        return self

    def set_size(self, size_y, size_x):
        self._inner_dx = size_x - 2
        self._inner_dy = size_y - 2
        return self

    def set_inner(self, inner_dy: int, inner_dx: int):
        self._inner_dy = inner_dy
        self._inner_dx = inner_dx
        return self

    def get_inner(self):
        return (self._inner_dy, self._inner_dx)

    def get_size(self):
        return self._inner_dy + 2, self._inner_dx + 2

    def set_end(self, y: int, x: int):
        self._inner_dx = x - self._x - 1
        self._inner_dy = y - self._y - 1
        return self

    def set_wrap(self):
        self._wrap = True
        return self

    def set_fill_char(self, char: str):
        self._fill_char = char
        return self

    def get_symbol(self, value: str):
        square = {"lu": "┌", "ru": "┐", "ld": "└", "rd": "┘", "h": "─", "v": "│"}
        rounded = {"lu": "╭", "ru": "╮", "ld": "╰", "rd": "╯", "h": "─", "v": "│"}
        bold = {"lu": "┏", "ru": "┓", "ld": "┗", "rd": "┛", "h": "━", "v": "┃"}

        if self._border == "square":
            return square[value]
        elif self._border == "rounded":
            return rounded[value]
        elif self._border == "bold":
            return bold[value]
        return " "

    def set_border_none(self):
        self._border = "none"
        return self

    def set_border_bold(self):
        self._border = "bold"
        return self

    def set_border_rounded(self):
        self._border = "rounded"
        return self

    def set_border_square(self):
        self._border = "square"
        return self

    def set_header(self, header: Sentence, align="<", prefix="", suffix=""):
        self._halign = align
        self._header = header
        self._hprefix = prefix
        self._hsuffix = suffix
        return self

    def set_footer(self, footer: Sentence, align=">", prefix="", suffix=""):
        self._falign = align
        self._footer = footer
        self._fprefix = prefix
        self._fsuffix = suffix
        return self

    def set_fill(self):
        self._filled = True
        return self

    def set_nofill(self):
        self._filled = False
        return self

    def print(self, x: int, sentence: Sentence):
        self.write(self._print_index, x, sentence)
        self._print_index += 1
        return self

    # return y, x of the last character
    def write(self, y: int, x: int, sentence: Sentence) -> bool:
        lines, cols = Fmt.get_size()

        x_min = max(-1, self._x)
        y_min = max(-1, self._y)
        x_max = min(cols, self._x + self._inner_dx)
        y_max = min(lines, self._y + self._inner_dy)

        x_abs = x + self._x + 1
        y_abs = y + self._y + 1

        if y_abs <= y_min or y_abs > y_max:
            return False
        count = 0
        for token in sentence.resume():
            fmt, text = token.fmt, token.text
            if x_abs - 1 < x_min:  # Se o texto começa fora do frame
                if x_abs + len(text) > x_min:  # mas ter parte dentro
                    text = text[x_min - x_abs + 1 :]
                    x_abs = x_min + 1
            if x_abs <= x_max:  # Se o texto começa dentro do frame
                if x_abs + len(text) >= x_max:
                    cut_point = x_max - x_abs + 1
                    text = text[:cut_point]

                Fmt.stroke(y_abs, x_abs, fmt, text)
                count += 1
            x_abs += len(text)
        return count != 0

    def draw(self):
        x = self._x
        y = self._y
        dx = self._inner_dx
        dy = self._inner_dy
        color = self._border_color
        up_left = self.get_symbol("lu")
        up_right = self.get_symbol("ru")
        down_left = self.get_symbol("ld")
        down_right = self.get_symbol("rd")
        hor = self.get_symbol("h")
        ver = self.get_symbol("v")

        header = self.get_full_header()
        footer = self.get_full_footer()

        above = Sentence().addf(color, up_left).add(header).addf(color, up_right)
        below = Sentence().addf(color, down_left).add(footer).addf(color, down_right)

        Fmt.write(y, x, above)
        if dy > 0:
            Fmt.write(y + dy + 1, x, below)
        if self._filled:
            for i in range(1, dy + 1):
                Fmt.write(
                    y + i,
                    x,
                    Sentence()
                    .addf(color, ver)
                    .add(dx * self._fill_char)
                    .addf(color, ver),
                )
        else:
            for i in range(1, dy + 1):
                Fmt.write(y + i, x, Sentence().addf(color, ver))
                Fmt.write(y + i, x + dx + 1, Sentence().addf(color, ver))
        return self



class Floating:
    def __init__(self, _align=""):
        self._frame = Frame(0, 0)
        self._content: List[Sentence] = []
        self._type = "warning"
        self._options = []
        self._options_index = 0
        self._fn_answer = None
        self._enable = True
        self._extra_exit: List[int] = []
        self._exit_fn = None
        self._exit_key = None
        self._centralize = True
        self._floating_align = _align

    def disable(self):
        self._enable = False

    def set_ljust_text(self):
        self._centralize = False
        return self

    def set_align(self, _align: str):
        self._floating_align = _align

    def set_header(self, text: str):
        self._frame.set_header(Sentence().addf("/", text), "")
        return self
    
    def set_header_sentence(self, sentence: Sentence):
        self._frame.set_header(sentence, "")
        return self
    
    def set_exit_key(self, key: str):
        self._exit_key = ord(key)
        return self

    def set_exit_fn(self, fn):
        self._exit_fn = fn
        return self

    def _set_xy(self, dy, dx):
        valid = "<>^v"
        for c in self._floating_align:
            if c not in valid:
                raise ValueError("Invalid align " + c)

        lines, cols = Fmt.get_size()

        x = (cols - dx) // 2
        if "<" in self._floating_align:
            x = 1
        elif ">" in self._floating_align:
            x = cols - dx - 3

        y = (lines - dy) // 2
        if "^" in self._floating_align:
            y = 1
        elif "v" in self._floating_align:
            y = lines - dy - 5

        self._frame.set_pos(y, x)
        return self
            
    def is_enable(self):
        return self._enable

    def __setup_frame(self):
        header_len = self._frame.get_header().len()
        footer_len = self._frame.get_footer().len()
        data = [x.len() for x in self._content] + [header_len, footer_len]
        max_dx = max(data)
        dx = max_dx
        dy = len(self._content)
        self._frame.set_inner(dy, dx)
        self._set_xy(dy, dx)
        self._frame.set_fill()
        
        if self._type == "answer":
            footer = Sentence().add(" ")
            for i, option in enumerate(self._options):
                fmt = "kG" if i == self._options_index else ""
                footer.addf(fmt, option).add(" ")
            self._frame.set_footer(footer, "^")

    def put_text(self, text: str):
        lines = text.split("\n")
        for line in lines:
            self._content.append(Sentence().add(line))
        return self

    def put_sentence(self, sentence: Sentence):
        self._content.append(sentence)
        return self
    
    def set_content(self, content: List[str]):
        self._content = [Sentence().add(x) for x in content]
        return self

    def _set_default_footer(self):
        if self._frame.get_footer().len() == 0:
            label = Sentence().addf("/", " Pressione espaço ")
            self._frame.set_footer(label, "", "─", "─")
        return self

    def _set_default_header(self):
        if self._frame.get_header().len() == 0:
            if self._type == "warning":
                self.set_header(" Aviso ")
            elif self._type == "error":
                self.set_header(" Erro ")
            elif self._type == "answer":
                self.set_header(" Pergunta ")

    def warning(self):
        self._type = "warning"
        self._frame.set_border_color("y")
        return self
    
    def error(self):
        self._type = "warning"
        self._frame.set_border_color("r")
        return self
    
    def answer(self, fn_answer):
        self._type = "answer"
        self._frame.set_border_color("g")
        self._fn_answer = fn_answer
        return self

    def set_options(self, options: List[str]):
        self._options = options
        return self

    def draw(self):
        self._set_default_header()
        self._set_default_footer()
        self.__setup_frame()
        self._frame.draw()
        y = 0

        for line in self._content:
            x = 0
            if self._centralize:
                x = (self._frame.get_dx() - line.len()) // 2
            self._frame.write(y, x, line)
            y += 1
        return self

    def get_input(self) -> int:
        self.draw()
        key: int = Fmt.getch()
        if self._type == "warning" or self._type == "error":
            if key < 300:
                self._enable = False
                if self._exit_fn is not None:
                    self._exit_fn()
                if self._exit_key is not None:
                    return self._exit_key
                if key == ord(" ") or key == 27:
                    return -1
                return key
        if self._type == "answer":
            if key == curses.KEY_LEFT:
                self._options_index = (self._options_index - 1) % len(self._options)
            elif key == curses.KEY_RIGHT:
                self._options_index = (self._options_index + 1) % len(self._options)
            elif key == 27:
                self._enable = False
            elif key == ord('\n'):
                self._enable = False
                if self._fn_answer is not None:
                    self._fn_answer(self._options[self._options_index])
                if self._exit_fn is not None:
                    self._exit_fn()
                if self._exit_key is not None:
                    return self._exit_key
                return -1
        return -1
        


class FloatingManager:
    def __init__(self):
        self.input_layer: List[Floating] = []

    def add_input(self, floating: Floating):
        self.input_layer.append(floating)

    def draw_warnings(self):
        if len(self.input_layer) > 0 and self.input_layer[0].is_enable():
            self.input_layer[0].draw()

    def has_floating(self) -> bool:
        while len(self.input_layer) > 0 and not self.input_layer[0].is_enable():
            self.input_layer = self.input_layer[1:]
        return len(self.input_layer) > 0 and self.input_layer[0].is_enable()

    def get_input(self) -> int:
        return self.input_layer[0].get_input()



class Report:
    __term_width: Optional[int] = None

    def __init__(self):
        pass

    @staticmethod
    def __get_terminal_size() -> int:
        term_width = shutil.get_terminal_size().columns
        if term_width % 2 == 0:
            term_width -= 1
        return term_width

    @staticmethod
    def get_terminal_size():
        if Report.__term_width is None:
            return Report.__get_terminal_size()
        return Report.__term_width

    @staticmethod
    def set_terminal_size(value: int):
        if value % 2 == 0:
            value -= 1
        Report.__term_width = value

    @staticmethod
    def centralize(
        ftext: Union[Sentence, str],
        sep: Optional[Union[str, Token]] = Token(" "),
        left_border: Optional[Union[str, Token]] = None,
        right_border: Optional[Union[str, Token]] = None,
    ) -> Sentence:

        if isinstance(ftext, str) or isinstance(ftext, Token):
            ftext = Sentence() + ftext
        if sep is None:
            sep = Token(" ")
        elif isinstance(sep, str):
            sep = Token(sep)
        if left_border is None:
            left_border = sep
        if right_border is None:
            right_border = sep
        term_width = Report.get_terminal_size()

        size = len(ftext)
        pad = sep if size % 2 == 0 else Token("")
        tw = term_width - 2
        filler = Token(sep.text * (int(tw / 2 - size / 2)), sep.fmt)
        return Sentence() + left_border + pad + filler + ftext + filler + right_border



class Diff:

    vinput    = " INSERIDO "
    vexpected = " ESPERADO "
    vreceived = " RECEBIDO "
    vunequal  = " DESIGUAL "

    @staticmethod
    def make_line_arrow_up(a: str, b: str) -> Sentence:
        hdiff = Sentence()
        first = True
        i = 0
        lim = max(len(a), len(b))
        while i < lim:
            if i >= len(a) or i >= len(b) or a[i] != b[i]:
                if first:
                    first = False
                    hdiff += symbols.arrow_up
                    return hdiff
            else:
                hdiff += " "
            i += 1
        while len(hdiff) < lim:
            hdiff += " "
        return hdiff

    @staticmethod
    def render_white(text: Sentence, color: str = "") -> Optional[Sentence]:
        out = Sentence().add(text).replace(' ', Token(symbols.whitespace.text, color)).replace('\n', Token(symbols.newline.text, color))

        return out

    # create a string with both ta and tb side by side with a vertical bar in the middle
    @staticmethod
    def side_by_side(ta: List[Sentence], tb: List[Sentence], unequal: Token = symbols.unequal) -> List[Sentence]:
        cut = (Report.get_terminal_size() - 6) // 2
        upper = max(len(ta), len(tb))
        data: List[Sentence] = []

        for i in range(upper):
            a = ta[i] if i < len(ta) else Sentence("###############")
            b = tb[i] if i < len(tb) else Sentence("###############")
            if len(a) < cut:
                a = a.ljust(cut, Token(" "))
            # if len(a) > cut:
            #     a = a[:cut]
            if i >= len(ta) or i >= len(tb) or ta[i] != tb[i]:
                data.append(Sentence() + unequal + " " + a + " " + unequal + " " + b)
            else:
                data.append(Sentence() + symbols.vbar + " " + a + " " + symbols.vbar + " " + b)

        return data

    # a_text -> clean full received
    # b_text -> clean full expected
    # first_failure -> index of the first line unmatched 
    @staticmethod
    def first_failure_diff(a_text: str, b_text: str, first_failure: int) -> List[Sentence]:
        def get(vet, index):
            if index < len(vet):
                return Diff.render_white(vet[index])
            return ""

        a_render = a_text.splitlines(True)
        b_render = b_text.splitlines(True)

        first_a = get(a_render, first_failure)
        first_b = get(b_render, first_failure)
        # greater = max(len(first_a), len(first_b))

        # if first_failure > 0:
        #     lbefore = get(a_render, first_failure - 1)
        #     greater = max(greater, len(lbefore))

        out_a, out_b = Diff.colorize_2_lines_diff(Sentence(first_a), Sentence(first_b))
        greater = max(len(out_a), len(out_b))
        output: List[Sentence] = []

        output.append(Sentence().add(symbols.vbar).add(" ").add(out_a.ljust(greater)).addf("g", " (esperado)"))
        output.append(Sentence().add(symbols.vbar).add(" ").add(out_b.ljust(greater)).addf("r", " (recebido)"))
        diff = Diff.make_line_arrow_up(first_a, first_b)
        output.append(Sentence().add(symbols.vbar).add(" ").add(diff.ljust(greater)).addf("b", " (primeiro)"))
        return output

    @staticmethod
    def find_first_mismatch(line_a: Sentence, line_b: Sentence) -> int: 
        i = 0
        while i < len(line_a) and i < len(line_b):
            if line_a[i] != line_b[i]:
                return i
            i += 1
        return i
    
    @staticmethod
    def colorize_2_lines_diff(la: Sentence, lb: Sentence, neut: str = "", exp: str = "g", rec: str = "r") -> Tuple[Sentence, Sentence]:
        pos = Diff.find_first_mismatch(la, lb)
        lat = la.get_text()
        lbt = lb.get_text()
        a_out = Sentence().addf(neut, lat[0:pos]).addf(exp, lat[pos:])
        b_out = Sentence().addf(neut, lbt[0:pos]).addf(rec, lbt[pos:])
        return a_out, b_out

    # return a tuple of two strings with the diff and the index of the  first mismatch line
    @staticmethod
    def render_diff(a_text: str, b_text: str, pad: Optional[bool] = None) -> Tuple[List[Sentence], List[Sentence], int]:
        a_lines = a_text.splitlines()
        b_lines = b_text.splitlines()

        a_output: List[Sentence] = []
        b_output: List[Sentence] = []

        a_size = len(a_lines)
        b_size = len(b_lines)
        
        first_failure = -1

        cut: int = 0
        if pad is True:
            cut = (Report.get_terminal_size() - 6) // 2

        max_size = max(a_size, b_size)

        # lambda function to return element in index i or empty if out of bounds
        def get(vet, index):
            out = ""
            if index < len(vet):
                out = vet[index]
            if pad is None:
                return out
            return out[:cut].ljust(cut)

        # get = lambda vet, i: vet[i] if i < len(vet) else ""

        for i in range(max_size):
            a_data = Sentence(get(a_lines, i))
            b_data = Sentence(get(b_lines, i))
            
            if i >= a_size or i >= b_size or a_lines[i] != b_lines[i]:
                if first_failure == -1:
                    first_failure = i
                a_out, b_out = Diff.colorize_2_lines_diff(a_data, b_data, "y")
                a_output.append(a_out)
                b_output.append(b_out)
            else:
                a_output.append(a_data)
                b_output.append(b_data)

        return a_output, b_output, first_failure

    @staticmethod
    def mount_up_down_diff(unit: Unit, curses=False) -> List[Sentence]:
        output: List[Sentence] = []

        string_input = unit.input
        string_expected = unit.output
        string_received = unit.user

        if string_received is None:
            string_received = ""
        expected_lines, received_lines, first_failure = Diff.render_diff(string_expected, string_received)
        string_input_list = [Sentence().add(symbols.vbar.text).add(" ").add(line) for line in string_input.split("\n")][:-1]
        unequal = symbols.unequal
        if unit.result == ExecutionResult.EXECUTION_ERROR or unit.result == ExecutionResult.COMPILATION_ERROR:
            unequal = symbols.vbar
        expected_lines, received_lines = Diff.put_left_equal(expected_lines, received_lines, unequal)

        color = "b" if string_expected != string_received else "g"
        if not curses:
            output.append(Report.centralize("", symbols.hbar, "╭"))
            output.append(Report.centralize(unit.str(), " ", symbols.vbar))
            output.append(Report.centralize(Sentence().addf(color, Diff.vinput), symbols.hbar, "├"))
        else:
            output.append(Report.centralize(Sentence().addf(color, Diff.vinput), symbols.hbar, "╭"))

        output += string_input_list
            
        output.append(Report.centralize(Sentence().addf("g", Diff.vexpected), symbols.hbar, "├"))
        output += expected_lines
        # output.append("\n".join(expected_lines))
        rcolor = "r" if string_expected != string_received else "g"
        output.append(Report.centralize(Sentence().addf(rcolor, Diff.vreceived), symbols.hbar, "├"))
        output +=  received_lines

        if unit.result != ExecutionResult.EXECUTION_ERROR and unit.result != ExecutionResult.COMPILATION_ERROR and string_expected != string_received:
            output.append(Report.centralize(Sentence().addf("b", Diff.vunequal),  symbols.hbar, "├"))
            output += Diff.first_failure_diff(string_expected, string_received, first_failure)
        output.append(Report.centralize("",  symbols.hbar, "╰"))

        return output

    @staticmethod
    def put_left_equal(exp_lines: List[Sentence], rec_lines: List[Sentence], unequal: Token = symbols.unequal):

        max_size = max(len(exp_lines), len(rec_lines))

        for i in range(max_size):
            if i >= len(exp_lines) or i >= len(rec_lines) or (exp_lines[i] != rec_lines[i]):
                exp_lines[i] = Sentence() + unequal + " " + exp_lines[i]
                rec_lines[i] = Sentence() + unequal + " " + rec_lines[i]
            else:
                exp_lines[i] = Sentence() + symbols.vbar + " " + exp_lines[i]
                rec_lines[i] = Sentence() + symbols.vbar + " " + rec_lines[i]
        
        return exp_lines, rec_lines
            
    @staticmethod
    def title_side_by_side(left: Sentence, right: Sentence, filler: Token = Token(" "), middle: Token = Token(" "), prefix: Token = Token()) -> Sentence:
        half = int((Report.get_terminal_size() - len(middle)) / 2)
        line = Sentence()
        a = left
        a = a.center(half, filler)
        if len(a) > half:
            a = a.trim_end(half)
        line += a
        line += middle
        b = right
        b = b.center(half, filler)
        if len(b) > half:
            b = b.trim_end(half)
        line += b
        if prefix != "":
            line.data[0].text = line.data[0].text[1:]
            line = Sentence() + prefix + line
        return line

    @staticmethod
    def mount_side_by_side_diff(unit: Unit, curses=False) -> List[Sentence]:

        output: List[Sentence] = []

        string_input = unit.input
        string_expected = unit.output
        string_received = unit.user
        if string_received is None:
            string_received = ""
        # dotted = "-"
        # vertical_separator = symbols.vbar
        hbar = symbols.hbar

        expected_lines, received_lines, first_failure = Diff.render_diff(string_expected, string_received, True)
        if not curses:
            output.append(Report.centralize("", hbar, "╭"))
            output.append(Report.centralize(unit.str(), " ", "│"))
        input_color = "b" if string_expected != string_received else "g"
        input_headera = Sentence().addf(input_color, Diff.vinput)
        input_headerb = Sentence().addf(input_color, Diff.vinput)
        if not curses:
            output.append(Diff.title_side_by_side(input_headera, input_headerb, hbar, Token("┬"), Token("├")))
        else:
            output.append(Report.centralize(Sentence().addf(input_color, Diff.vinput),  symbols.hbar, "╭"))
            # output.append(Diff.title_side_by_side(input_headera, input_headerb, hbar, TK("┬"), TK("╭")))

        if string_input != "":
            lines = [Sentence(x) for x in string_input.split("\n")[:-1]]
            output += Diff.side_by_side(lines, lines)
        expected_header = Sentence().addf("g", Diff.vexpected)
        rcolor = "r" if string_expected != string_received else "g"
        received_header = Sentence().addf(rcolor, Diff.vreceived)
        output.append(Diff.title_side_by_side(expected_header, received_header, hbar, Token("┼"), Token("├")))
        unequal = symbols.unequal
        if unit.result == ExecutionResult.EXECUTION_ERROR or unit.result == ExecutionResult.COMPILATION_ERROR:
            unequal = symbols.vbar
        output += Diff.side_by_side(expected_lines, received_lines, unequal)
        if unit.result != ExecutionResult.EXECUTION_ERROR and unit.result != ExecutionResult.COMPILATION_ERROR and string_expected != string_received:
            output.append(Report.centralize(Sentence().addf("b", Diff.vunequal),  symbols.hbar, "├"))
            output += Diff.first_failure_diff(string_expected, string_received, first_failure)
            output.append(Report.centralize("",  symbols.hbar, "╰"))
        else:
            output.append(Report.centralize("┴",  symbols.hbar, "╰"))

        return output


class Runner:
    def __init__(self):
        pass

    @staticmethod
    def subprocess_run(cmd: str, input_data: str = "", timeout:Optional[float] = None) -> Tuple[int, str, str]:
        try:
            answer = subprocess.run(cmd, shell=True, input=input_data, stdout=PIPE, stderr=PIPE, text=True, timeout=timeout)
            err = ""
            if answer.returncode != 0:
                err = answer.stderr + Runner.decode_code(answer.returncode)
            # if running on windows
            if os.name == "nt":
                return answer.returncode, answer.stdout.encode("cp1252").decode("utf-8"), err
            return answer.returncode, answer.stdout, err
        except subprocess.TimeoutExpired:
            err = "fail: processo abortado depois de {} segundos".format(timeout)
            return 1, "", err



    @staticmethod
    def clear_screen():
        if os.name == 'nt':
            os.system('cls')
        else:
            os.system('clear')

    @staticmethod
    def decode_code(return_code: int) -> str:
        code = 128 - return_code
        if code == 127:
            return ""
        if code == 139:
            return "fail: segmentation fault"
        if code == 134:
            return "fail: runtime exception"
        return "fail: execution error code " + str(code)

# class Runner:

#     def __init__(self):
#         pass

#     @staticmethod
#     def subprocess_run(cmd_list: List[str], input_data: str = "") -> Tuple[int, Any, Any]:
#         try:
#             p = subprocess.Popen(cmd_list, stdout=PIPE, stdin=PIPE, stderr=PIPE, universal_newlines=True)
#             stdout, stderr = p.communicate(input=input_data)
#             return p.returncode, stdout, stderr
#         except FileNotFoundError:
#             print("\n\nCommand not found: " + " ".join(cmd_list))
#             exit(1)




class CompileError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message



class Solver:
    def __init__(self, solver_list: List[str]):
        self.path_list: List[str] = [os.path.normpath(Solver.__add_dot_bar(path)) for path in solver_list]
        
        self.temp_dir = tempfile.mkdtemp()
        self.error_msg: str = ""
        self.__executable: str = ""
        self.compile_error: bool = False

    def check_tool(self, name):
        if shutil.which(name) is None:
            self.compile_error = True
            raise CompileError("fail: comando '" + name + "' não foi encontrado")

    def set_main(self, main: str):
        list_main: List[str] = []
        list_other: List[str] = []

        for path in self.path_list:
            if os.path.basename(path) == main:
                list_main.append(path)
            else:
                list_other.append(path)
        
        self.path_list = list_main + list_other
        return self

    def set_executable(self, executable: str):
        self.__executable = executable
        return self

    def reset(self):
        self.__executable = ""
        self.compile_error = False
        self.error_msg = ""

    def not_compiled(self):
        return self.__executable == "" and not self.compile_error

    def get_executable(self, force_rebuild=False) -> str:
        if (len(self.path_list) > 0 and self.not_compiled()) or force_rebuild:
            self.prepare_exec()
        return self.__executable

    def prepare_exec(self) -> None:
        self.__executable = ""
        path = self.path_list[0]
        self.compile_error = False

        if path.endswith(".py"):
            self.__executable = "python " + path
        elif path.endswith(".js"):
            self.__prepare_js()
        elif path.endswith(".ts"):
            self.__prepare_ts()
        elif path.endswith(".java"):
            self.__prepare_java()
        elif path.endswith(".c"):
            self.__prepare_c()
        elif path.endswith(".cpp"):
            self.__prepare_cpp()
        elif path.endswith(".go"):
            self.__prepare_go()
        elif path.endswith(".sql"):
            self.__prepare_sql()
        else:
            self.__executable = path

    def __prepare_java(self):
        self.check_tool("javac")

        solver = self.path_list[0]

        filename = os.path.basename(solver)
        # tempdir = os.path.dirname(self.path_list[0])

        cmd = ["javac"] + self.path_list + ['-d', self.temp_dir]
        cmdt = " ".join(cmd)
        return_code, stdout, stderr = Runner.subprocess_run(cmdt)
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            self.__executable = "java -cp " + self.temp_dir + " " + filename[:-5]  # removing the .java

    def __prepare_js(self):
        self.check_tool("node")
        solver = self.path_list[0]
        self.__executable = "node " + solver

    def __prepare_go(self):
        self.check_tool("go")
        solver = self.path_list[0]
        self.__executable = "go run " + solver

    def __prepare_sql(self):
        self.check_tool("sqlite3")
        self.__executable = "cat " + " ".join(self.path_list) + " | sqlite3"

    def __prepare_ts(self):
        transpiler = "esbuild"
        if os.name == "nt":
            transpiler += ".cmd"

        self.check_tool(transpiler)
        self.check_tool("node")

        solver = self.path_list[0]

        filename = os.path.basename(solver)
        source_list = self.path_list
        cmd = [transpiler] + source_list + ["--outdir=" + self.temp_dir, "--format=cjs", "--log-level=error"]
        return_code, stdout, stderr = Runner.subprocess_run(" ".join(cmd))
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            jsfile = os.path.join(self.temp_dir, filename[:-3] + ".js")
            self.__executable = "node " + jsfile  # renaming solver to main
    
    def __prepare_c_cpp(self, pre_args: List[str], pos_args: List[str]):
        # solver = self.path_list[0]
        tempdir = self.temp_dir
        source_list = self.path_list
        # print("Using the following source files: " + str([os.path.basename(x) for x in source_list]))
        
        exec_path = os.path.join(tempdir, ".a.out")
        cmd = pre_args + source_list + ["-o", exec_path] + pos_args
        return_code, stdout, stderr = Runner.subprocess_run(" ".join(cmd))
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            self.__executable = exec_path

    def __prepare_c(self):
        self.check_tool("gcc")
        pre = ["gcc", "-Wall"]
        pos = ["-lm"]
        self.__prepare_c_cpp(pre, pos)

    def __prepare_cpp(self):
        self.check_tool("g++")
        pre = ["g++", "-std=c++17", "-Wall", "-Wextra", "-Werror"]
        pos: List[str] = []
        self.__prepare_c_cpp(pre, pos)

    @staticmethod
    def __add_dot_bar(solver: str) -> str:
        if os.sep not in solver and os.path.isfile("." + os.sep + solver):
            solver = "." + os.sep + solver
        return solver
    


class Execution:

    def __init__(self):
        pass

    # run a unit using a solver and return if the result is correct
    @staticmethod
    def run_unit(solver: Solver, unit: Unit, timeout: Optional[float]=None) -> ExecutionResult:
        if solver.compile_error:
            unit.user = solver.error_msg
            return ExecutionResult.COMPILATION_ERROR
        cmd = solver.get_executable()
        if timeout == 0:
            timeout = None
        return_code, stdout, stderr = Runner.subprocess_run(cmd, unit.input, timeout)
        unit.user = stdout + stderr
        if return_code != 0:
            return ExecutionResult.EXECUTION_ERROR
        if unit.user == unit.output:
            return ExecutionResult.SUCCESS
        return ExecutionResult.WRONG_OUTPUT


class Wdir:
    def __init__(self):
        self.__autoload = False
        self.__autoload_folder = ""
        self.__solver: Optional[Solver] = None
        self.__source_list: List[str] = []
        self.__pack_list: List[List[Unit]] = []
        self.__unit_list: List[Unit] = []
        self.__curses = False
        self.__lang = ""

    def has_solver(self) -> bool:
        return not self.__solver is None

    def has_tests(self) -> bool:
        return len(self.__unit_list) != 0

    def get_solver(self) -> Solver:
        if self.__solver is None:
            raise Warning("fail: Não foi encontrado arquivo de código")
        return self.__solver
    
    def get_unit_list(self) -> List[Unit]:
        return self.__unit_list

    def get_unit(self, index: int) -> Unit:
        return self.__unit_list[index]
    
    def get_source_list(self) -> List[str]:
        return self.__source_list

    def set_curses(self, value: bool):
        self.__curses = value
        return self

    def set_lang(self, lang: str):
        self.__lang = lang
        return self
    
    def is_curses(self) -> bool:
        return self.__curses

    def is_autoload(self) -> bool:
        return self.__autoload

    def get_autoload_folder(self) -> str:
        return self.__autoload_folder

    def set_solver(self, solver_list: List[str]):
        if len(solver_list) > 0:
            self.__solver = Solver(solver_list)
        return self

    def set_sources(self, source_list: List[str]):
        self.__source_list = source_list
        return self

    def autoload(self):
        folder = self.__autoload_folder
        files = os.listdir(folder)
        files = [os.path.join(folder, f) for f in files]
        files = [f for f in files if os.path.isfile(f)]

        sources = [target for target in files if target.endswith(".tio")]
        if self.__lang != "":
            solvers = [target for target in files if target.endswith("." + self.__lang)]
        else:
            solvers = [target for target in files if any([target.endswith("." + lang) for lang in languages_avaliable])]

        solvers = sorted(solvers)

        # if not self.__curses:
        #     print("códigos encontrados: [" + ", ".join(solvers) + "]")
        #     print("testes  encontrados: [" + ", ".join(sources) + "]")
            # print("Para remover um arquivo da lista, renomeie para sua extensão para .txt")
        self.set_solver(solvers)
        self.set_sources(sources)
        self.__autoload = True
        return self

    def set_target_list(self, target_list: List[str]):
        target_list = [os.path.normpath(t) for t in target_list]
        if len(target_list) == 0:
            target_list.append(".")
        if len(target_list) == 1 and os.path.isdir(target_list[0]):
            self.__autoload_folder = target_list[0]
            return self.autoload()
            
        target_list = [t for t in target_list if t != ""]
        for target in target_list:
            if not os.path.exists(target):
                raise FileNotFoundError(f"fail: {target} não encontrado")

        solvers = [target for target in target_list if Identifier.get_type(target) == IdentifierType.SOLVER]
        sources = [target for target in target_list if Identifier.get_type(target) != IdentifierType.SOLVER]
        
        self.set_solver(solvers)
        self.set_sources(sources)
        return self

    def set_cmd(self, exec_cmd: Optional[str]):
        if exec_cmd is None:
            return self
        if self.__solver is not None:
            print("fail: if using --cmd, don't pass source files to target")
        self.__solver = Solver([])
        self.__solver.set_executable(exec_cmd)
        return self

    def build(self):
        loading_failures = 0
        self.__pack_list = []
        for source in self.__source_list:
            try:
                self.__pack_list.append(Loader.parse_source(source))
            except FileNotFoundError as e:
                print(str(e))
                loading_failures += 1
                pass
        if loading_failures > 0 and loading_failures == len(self.__source_list):
            raise FileNotFoundError("failure: nenhum arquivo de teste encontrado")
        self.__unit_list = sum(self.__pack_list, [])
        self.__number_and_mark_duplicated()
        self.__calculate_grade()
        self.__pad()
        return self

    def calc_grade(self) -> int:
        grade = 100
        for case in self.__unit_list:
            if not case.repeated and (case.user is None or case.output != case.user):
                grade -= case.grade_reduction
        return max(0, grade)

    # put all the labels with the same length
    def __pad(self):
        if len(self.__unit_list) == 0:
            return
        max_case = max([len(x.case) for x in self.__unit_list])
        max_source = max([len(x.source) for x in self.__unit_list])
        for unit in self.__unit_list:
            unit.case_pad = max_case
            unit.source_pad = max_source

    # select a single unit to execute exclusively
    def filter(self, param: Param.Basic):
        index = param.index
        if index is not None:
            if 0 <= index < len(self.__unit_list):
                self.__unit_list = [self.__unit_list[index]]
            else:
                raise ValueError("Índice fora dos limites: " + str(index))
        return self

    # calculate the grade reduction for the cases without grade
    # the grade is proportional to the number of unique cases
    def __calculate_grade(self):
        unique_count = len([x for x in self.__unit_list if not x.repeated])
        for unit in self.__unit_list:
            if unit.grade is None:
                unit.grade_reduction = math.floor(100 / unique_count)
            else:
                unit.grade_reduction = unit.grade

    # number the cases and mark the repeated
    def __number_and_mark_duplicated(self):
        new_list: List[Unit] = []
        index = 0
        for unit in self.__unit_list:
            unit.index = index
            index += 1
            search = [x for x in new_list if x.input == unit.input]
            if len(search) > 0:
                unit.repeated = search[0].index
            new_list.append(unit)
        self.__unit_list = new_list

    # sort, unlabel ou rename using the param received
    def manipulate(self, param: Param.Manip):
        # filtering marked repeated
        self.__unit_list = [unit for unit in self.__unit_list if unit.repeated is None]
        if param.to_sort:
            self.__unit_list.sort(key=lambda v: len(v.input))
        if param.unlabel:
            for unit in self.__unit_list:
                unit.case = ""
        if param.to_number:
            number = 00
            for unit in self.__unit_list:
                unit.case = LabelFactory().label(unit.case).index(number).generate()
                number += 1

    def unit_list_resume(self) -> List[Sentence]:
        return [unit.str() for unit in self.__unit_list]

    def sources_names(self) -> List[Tuple[str, int]]:
        out: List[Tuple[str, int]] = []
        if len(self.__pack_list) == 0:
            out.append((symbols.failure.text, 0))
        for i in range(len(self.__pack_list)):
            nome: str = self.__source_list[i].split(os.sep)[-1]
            out.append((nome, len(self.__pack_list[i])))
        return out

    def solvers_names(self) -> List[str]:
        path_list = [] if self.__solver is None else self.__solver.path_list
        if self.__solver is not None and len(path_list) == 0:  # free_cmd
            out = ["free cmd"]
        else:
            out = [os.path.basename(path) for path in path_list]
        return out

    def resume(self) -> Sentence:
        sources = ["{}({})".format(name, str(count).rjust(2, "0")) for name, count in self.sources_names()]
        __sources = Sentence().add("Testes:").add("[").addf("y", ", ".join(sources)).add("]")

        __solvers = Sentence().add("Códigos:").add("[").addf("g", ", ".join(self.solvers_names())).add("]")

        return Sentence().add(__solvers).add(" ").add(__sources)


class Free:
    @staticmethod
    def free_run(solver: Solver, show_compilling:bool=True, to_clear: bool=True, wait_input:bool=True) -> bool:
        if to_clear:
            Runner.clear_screen()
        if show_compilling:
            image = random.choice(list(compilling.keys()))
            for line in compilling[image].split("\n"):
                term_print(Report.centralize(Sentence().addf("y", line), Token(" ")))

        if show_compilling:
            Runner.clear_screen()
        solver.prepare_exec()
        if solver.compile_error:
            print(solver.error_msg)
        else:
            cmd = solver.get_executable()
            term_print(Report.centralize(Sentence() + " " + cmd + " ", "─"))
            if cmd.startswith("node"):
                if os.name == "nt":
                    term_print(Report.centralize(Sentence() + " Use Control-Z Enter caso precise finalizar a entrada ", "─"))
                else:
                    term_print(Report.centralize(Sentence() + " Use Control-D caso precise finalizar a entrada ", "─"))
                
            answer = subprocess.run(cmd, shell=True, text=True)
            if answer.returncode != 0 and answer.returncode != 1:
                print(Runner.decode_code(answer.returncode))
            
        if wait_input:
            term_print(Report.centralize("", "─"))
            term_print(Sentence().addf("y", "Pressione (Enter) para executar novamente ou (q Enter) para sair: "), end="")
            valor = input()
            if valor != "q":
                if to_clear:
                    Runner.clear_screen()
                return True
        if to_clear:
            Runner.clear_screen()
        return False

def uni_to_asc(input_str: str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)])

class SearchAsc:
    def __init__(self, pattern: str):
        self.pattern = uni_to_asc(pattern.lower())

    def find(self, title: str) -> int:
        return uni_to_asc(title.lower()).find(self.pattern)
    
    def inside(self, title: str) -> bool:
        return self.find(title) != -1


def load_html_tags(task: str) -> Optional[str]:
    pattern = r"<!--\s*(.*?)\s*-->"
    match = re.search(pattern, task)
    if not match:
        return None
    return match.group(1).strip()


class Game:
    def __init__(self, file: Optional[str] = None):
        self.ordered_clusters: List[str] = [] # ordered clusters
        self.clusters: Dict[str, Cluster] = {} 
        self.quests: Dict[str, Quest] = {}  # quests indexed by quest key
        self.tasks: Dict[str, Task] = {}  # tasks indexed by task key

        self.available_quests: List[str] = []
        self.available_clusters: List[str] = []

        self.token_level_one = "level_one"
        self.token_level_mult = "level_mult"
        self.level_one = 100
        self.level_mult = 1.5

        self.filename = None
        if file is not None:
            self.filename = file
            self.parse_file(file)

    def parse_xp(self, line: str):
        values = load_html_tags(line)
        if values is not None:
            tags = values.split(" ")
            for t in tags:
                if t.startswith(self.token_level_one):
                    self.level_one = int(t.split(":")[1])
                if t.startswith(self.token_level_mult):
                    self.level_mult = float(t.split(":")[1])

    def get_task(self, key: str) -> Task:
        if key in self.tasks:
            return self.tasks[key]
        raise Warning(f"fail: tarefa '{key}' não encontrada no curso")

    # se existir um cluster nessa linha, insere na lista de clusters e 
    # retorno o objeto cluster inserido
    def load_cluster(self, line: str, line_num: int) -> Optional[Cluster]:
        pattern = r"^#+\s*(.*?)<!--\s*(.*?)\s*-->\s*$"
        match = re.match(pattern, line)
        if not match:
            return None
        titulo = match.group(1)
        tags_raw = match.group(2).strip()
        tags = [tag.strip() for tag in tags_raw.split(" ")]
        if "group" not in tags:
            return None
        
        keys = [tag[1:] for tag in tags if tag.startswith("@")]
        key = uni_to_asc(get_md_link(titulo))
        try:
            color = [tag[2:] for tag in tags if tag.startswith("c:")][0]
        except IndexError as _e:
            color = None
        if len(keys) > 0:
            key = keys[0]
        
        cluster = Cluster(line_num, titulo, key, color)

        if key in self.clusters.keys():
            c = self.clusters[key]
            print(f"Cluster {key} já existe")
            print(f"{self.filename}:{line_num}")
            print(f"{self.filename}:{c.line_number}")
            print("  " + str(c))
            print("  " + str(cluster))
            exit(1)
                
        self.clusters[key] = cluster
        self.ordered_clusters.append(key)
        return cluster
                
    def load_quest(self, line, line_num) -> Optional[Quest]:
        quest = QuestParser().parse_quest(self.filename, line, line_num + 1)
        if quest is None:
            return None
        if quest.key in self.quests:
            print(f"Quest {quest.key} já existe")
            print(f"{self.filename}:{quest.line_number}")
            print(f"{self.filename}:{self.quests[quest.key].line_number}")
            print("  " + str(quest))
            print("  " + str(self.quests[quest.key]))
            exit(1)
        self.quests[quest.key] = quest
        return quest

    def load_task(self, line, line_num) -> Optional[Task]:
        if line == "":
            return None
        task = TaskParser.parse_line(line, line_num + 1)
        if task is None:
            return None
        
        if task.key in self.tasks:
            print(f"Task {task.key} já existe")
            print(f"{self.filename}:{task.line_number}")
            print(f"{self.filename}:{self.tasks[task.key].line_number}")
            print("  " + str(task))
            print("  " + str(self.tasks[task.key]))
            exit(1)
        self.tasks[task.key] = task
        return task

    def get_xp_resume(self):
        total = 0
        obtained = 0
        for q in self.quests.values():
            o, t = q.get_xp()
            total += t
            obtained += o
        return obtained, total

    def get_skills_resume(self, avaliable_quests: List[Quest]) -> Tuple[Dict[str, int], Dict[str, int]]:
        total: Dict[str, int] = {}
        obtained: Dict[str, int] = {}
        avaliable_keys = [q.key for q in avaliable_quests]
        for q in self.quests.values():
            reachable = q.key in avaliable_keys
            for t in q.get_tasks():
                for s in t.skills:
                    if s in total:
                        total[s] += t.skills[s]
                        if reachable:
                            obtained[s] += int(t.skills[s] * t.grade/10)
                        else:
                            obtained[s] += 0
                    else:
                        total[s] = t.skills[s]
                        if reachable:
                            obtained[s] = int(t.skills[s] * t.grade/10)
                        else:
                            obtained[s] = 0
                for s in t.qskills:
                    if s in total:
                        total[s] += t.qskills[s]
                        if reachable:
                            obtained[s] += int(t.qskills[s] * t.grade/10)
                        else:
                            obtained[s] += 0
                    else:
                        total[s] = t.qskills[s]
                        if reachable:
                            obtained[s] = int(t.qskills[s] * t.grade/10)
                        else:
                            obtained[s] = 0
        return total, obtained

    # Verificar se todas as quests requeridas existem e adiciona o ponteiro
    # Verifica se todas as quests tem tarefas
    def validate_requirements(self):

        # verify is there are keys repeated between quests, tasks and groups

        keys = [c.key for c in self.clusters.values()] +\
               [k for k in self.quests.keys()] +\
               [k for k in self.tasks.keys()]

        # print chaves repetidas
        for k in keys:
            if keys.count(k) > 1:
                print(f"Chave repetida: {k}")
                exit(1)

        # remove all quests without tasks
        valid_quests = {}
        for k, q in self.quests.items():
            if len(q.get_tasks()) > 0:
                valid_quests[k] = q

        # trim titles
        for q in self.quests.values():
            q.title = q.title.strip()
        for c in self.clusters.values():
            c.title = c.title.strip()

        self.quests = valid_quests

        # verificar se todas as quests requeridas existem e adicionar o ponteiro
        for q in self.quests.values():
            for r in q.requires:
                if r in self.quests:
                    q.requires_ptr.append(self.quests[r])
                else:
                    # print(f"keys: {self.quests.keys()}")
                    print(f"Quest\n{self.filename}:{q.line_number}\n{str(q)}\nrequer {r} que não existe")
                    exit(1)

    def check_cycle(self):
        def dfs(qx, visitedx):
            if len(visitedx) > 0:
                if visitedx[0] == qx.key:
                    print(f"Cycle detected: {visitedx}")
                    exit(1)
            if q.key in visitedx:
                return
            visitedx.append(q.key)
            for r in q.requires_ptr:
                dfs(r, visitedx)

        for q in self.quests.values():
            visited: List[str] = []
            dfs(q, visited)

    def parse_file(self, file):
        self.filename = file
        lines = open(file, encoding="utf-8").read().split("\n")
        active_quest = None
        active_cluster = None

        if len(lines) > 0:
            self.parse_xp(lines[0])

        for line_num, line in enumerate(lines):
            cluster = self.load_cluster(line, line_num)
            if cluster is not None:
                active_cluster = cluster
                continue
            
            quest = self.load_quest(line, line_num)
            if quest is not None:
                active_quest = quest
                if active_cluster is None:
                    key = "Sem Grupo"
                    cluster = Cluster(0, key, key)
                    self.clusters[key] = cluster
                    self.ordered_clusters.append(key)
                    active_cluster = cluster
                quest.cluster = active_cluster.key
                active_cluster.quests.append(quest)
                continue

            task = self.load_task(line, line_num)
            if task is not None:
                
                if active_quest is None:
                    print(f"Task {task.key} não está dentro de uma quest")
                    print(f"{file}:{task.line_number}")
                    print(f"  {task}")
                    exit(1)
                if self.filename is not None:
                    active_quest.add_task(task, self.filename)

        self.clear_empty()

        self.validate_requirements()
        for t in self.tasks.values():
            t.process_link(os.path.dirname(file) + "/")

    def clear_empty(self):

        # apagando quests vazias da lista de quests
        for k in list(self.quests.keys()):
            if len(self.quests[k].get_tasks()) == 0:
                del self.quests[k]

        # apagando quests vazias dos clusters e clusters vazios
        ordered_clusters: List[str] = []
        clusters: Dict[str, Cluster] = {}
        for key in self.ordered_clusters:
            cluster = self.clusters[key]
            quests = [q for q in cluster.quests if len(q.get_tasks()) > 0]
            if len(quests) > 0:
                cluster.quests = quests
                clusters[cluster.key] = cluster
                ordered_clusters.append(cluster.key)

        self.ordered_clusters = ordered_clusters
        self.clusters = clusters

    @staticmethod
    def __is_reachable_quest(q: Quest, cache: Dict[str, bool]):
        if q.key in cache:
            return cache[q.key]

        if len(q.requires_ptr) == 0:
            cache[q.key] = True
            return True
        cache[q.key] = all([r.is_complete() and Game.__is_reachable_quest(r, cache) for r in q.requires_ptr])
        return cache[q.key]

    # def __get_reachable_quests(self):
    #     # cache needs to be reseted before each call
    #     cache: Dict[str, bool] = {}
    #     return [q for q in self.quests.values() if Game.__is_reachable_quest(q, cache)]

    def update_reachable_and_available(self, admin_mode: bool):
        for q in self.quests.values():
            q.set_reachable(False)
        for c in self.clusters.values():
            c.set_reachable(False)

        cache: Dict[str, bool] = {}
        for c in self.clusters.values():
            for q in c.quests:
                if Game.__is_reachable_quest(q, cache):
                    q.set_reachable(True)
                    c.set_reachable(True)

        self.available_quests = []
        self.available_clusters = []
        if admin_mode:
            self.available_quests = [key for key in self.quests.keys()]
            self.available_clusters = [key for key in self.clusters.keys()]
        else:
            self.available_quests = [q.key for q in self.quests.values() if q.is_reachable()]
            self.available_clusters = [c.key for c in self.clusters.values() if c.is_reachable()]


    def __str__(self):
        output = []
        for c in self.clusters.values():
            output.append(str(c))
            for q in c.quests:
                output.append(str(q))
                for t in q.get_tasks():
                    output.append(str(t))
        return "\n".join(output)



class Down:
    fnprint: Callable[[str], None] = print

    ts_draft = r"""
let _cin_ : string[] = [];
try { _cin_ = require("fs").readFileSync(0).toString().split(/\r?\n/); } catch(e){}
let input = () : string => _cin_.length === 0 ? "" : _cin_.shift()!;
let write = (text: any, end:string="\n")=> process.stdout.write("" + text + end);
export {};

write("qxcode");
"""[1:]

    js_draft = r"""
let __lines = require("fs").readFileSync(0).toString().split("\n");
let input = () => __lines.length === 0 ? "" : __lines.shift();
let write = (text, end="\n") => process.stdout.write("" + text + end);

write("qxcode");
"""[1:]

    c_draft = r"""
#include <stdio.h>

int main() {
    puts("qxcode");
    return 0;
}

"""[1:]
    
    cpp_draft = r"""
#include <iostream>

int main() {
    std::cout << "qxcode\n";
}

"""[1:]
    
    java_draft = r"""
public class draft {
    public static void main(String args[]) {
        System.out.println("qxcode");
    }
}

"""[1:]

    go_draft = (
        r"package main""\n"
        r'import "fmt"'"\n"
        r"func main() {""\n"
        r'    fmt.Println("qxcode")''\n'
        r"}""\n"
    )


    drafts = {'c': c_draft, 'cpp': cpp_draft, 'ts': ts_draft, 'js': js_draft, 'java': java_draft, 'go': go_draft}
    # def __init__(self):
    #     self.drafts = {}
    #     self.drafts['c'] = Down.c_draft
    #     self.drafts['cpp'] = Down.cpp_draft
    #     self.drafts['ts'] = Down.ts_draft
    #     self.drafts['js'] = Down.js_draft

    # @staticmethod
    # def update():
    #     if os.path.isfile(".info"):
    #         data = open(".info", "r").read().split("\n")[0]
    #         data = data.split(" ")
    #         discp = data[0]
    #         label = data[1]
    #         ext = data[2]
    #         Down.entry_unpack(".", discp, label, ext)
    #     else:
    #         print("No .info file found, skipping update...")

    @staticmethod
    def __create_file(content, path, label=""):
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        Down.fnprint("  " + path + " " + label)

    @staticmethod
    def __unpack_json(loaded, destiny, lang: str):
        # extracting all files to folder
        for entry in loaded["upload"]:
            if entry["name"] == "vpl_evaluate.cases":
                Down.__compare_and_save(entry["contents"], os.path.join(destiny, "cases.tio"))

        # for entry in loaded["keep"]:
        #    Down.compare_and_save(entry["contents"], os.path.join(destiny, entry["name"]))

        # for entry in loaded["required"]:
        #    path = os.path.join(destiny, entry["name"])
        #    Down.compare_and_save(entry["contents"], path)

        if "draft" in loaded:
            if lang in loaded["draft"]:
                for file in loaded["draft"][lang]:
                    path = os.path.join(destiny, file["name"])
                    Down.__create_file(file["contents"], path, "(Draft)")

    @staticmethod
    def __compare_and_save(content, path):
        if not os.path.exists(path):
            with open(path, "w", encoding="utf-8") as f:
                f.write(content.encode("utf-8").decode("utf-8"))
            Down.fnprint("  " + path + " (Novo)")
        else:
            if open(path, encoding="utf-8").read() != content:
                Down.fnprint(path + " (Atualizado)")
                with open(path, "w", encoding="utf-8") as f:
                    f.write(content)
            else:
                Down.fnprint("  " + path + " (Inalterado)")

    @staticmethod
    def __down_problem_def(destiny, cache_url) -> Tuple[str, str]:
        # downloading Readme
        readme = os.path.join(destiny, "Readme.md")
        [tempfile, __content] = urllib.request.urlretrieve(cache_url + "Readme.md")

        # content = ""
        try:
            content = open(tempfile, encoding="utf-8").read()
        except FileNotFoundError:
            content = open(tempfile, encoding="utf-8").read()

        Down.__compare_and_save(content, readme)

        # downloading mapi
        mapi = os.path.join(destiny, "mapi.json")
        urllib.request.urlretrieve(cache_url + "mapi.json", mapi)
        return readme, mapi

    @staticmethod
    def __create_problem_folder(rootdir: str, activity: str) -> str:
        # create dir
        destiny: str = os.path.join(rootdir, activity)
        if not os.path.exists(destiny):
            os.makedirs(destiny, exist_ok=True)
        else:
            Down.fnprint("  Pasta do problema "+ destiny + " encontrada, juntando conteúdo.")

        return destiny

    @staticmethod
    def download_problem(course: str, activity: str, language: Optional[str], fnprint: Callable[[str], None], game: Optional[Game] = None) -> bool:
        Down.fnprint = fnprint
        
        settings = Settings()
        rep_dir = os.path.join(settings.app.get_rootdir(), course)
        rep_source = settings.get_rep_source(course)
        rep_data = settings.get_rep_data(course)
        if game is None:
            try:
                file = rep_source.get_file(rep_dir)
            except urllib.error.HTTPError:
                Down.fnprint("falha: Verifique sua internet")
            game = Game(file)
        item = game.get_task(activity)
        if not item.link.startswith("http"):
            Down.fnprint("falha: link para atividade não é um link remoto")
            return False
        cfg = RemoteCfg(item.link)
        cache_url = os.path.dirname(cfg.get_raw_url()) + "/.cache/"

        destiny = Down.__create_problem_folder(rep_dir, activity)
        destiny = os.path.abspath(destiny)
        try:
            [_readme_path, mapi_path] = Down.__down_problem_def(destiny, cache_url)
        except urllib.error.HTTPError:
            Down.fnprint("  falha: atividade não encontrada no curso")
            # verifi if destiny folder is empty and remove it
            if len(os.listdir(destiny)) == 0:
                os.rmdir(destiny)
            return False
        except urllib.error.URLError:
            Down.fnprint("  falha: não consegui baixar a atividade, verifique sua internet")
            return False


        with open(mapi_path, encoding="utf-8") as f:
            loaded_json = json.load(f)
        os.remove(mapi_path)

        language_def = rep_data.get_lang()
        if language_def == "":
            language_def = Settings().app.get_lang_def()
        ask_ext = False
        if language is None:
            if language_def != "":
                language = language_def
            else:
                print("  Escolha uma extensão para os rascunhos: [c, cpp, py, ts, js, java]: ", end="")
                language = input()
                ask_ext = True

        Down.__unpack_json(loaded_json, destiny, language)
        Down.__download_drafts(loaded_json, destiny, language, cache_url, ask_ext)
        return True

    @staticmethod
    def __download_drafts(loaded_json, destiny: str, language, cache_url, ask_ext):
        if len(loaded_json["required"]) == 1:  # you already have the students file
            return

        if "draft" in loaded_json and language in loaded_json["draft"]:
            pass
        else:
            try:
                draft_path = os.path.join(destiny, "draft." + language)
                urllib.request.urlretrieve(cache_url + "draft." + language, draft_path)
                Down.fnprint("  " + draft_path + " (Rascunho) Renomeie antes de modificar")

            except urllib.error.HTTPError:  # draft not found
                filename = "draft."
                draft_path = os.path.join(destiny, filename + language)
                if not os.path.exists(draft_path):
                    with open(draft_path, "w", encoding="utf-8") as f:
                        if language in Down.drafts:
                            f.write(Down.drafts[language])
                        else:
                            f.write("")
                    Down.fnprint("  " + draft_path + " (Vazio)")

        if ask_ext:
            print("\nVocê pode escolher a extensão padrão com o comando\n$ tko config -l <extension>")





class Entry:
    def __init__(self, obj: Union[Task, Quest, Cluster], sentence: Sentence):
        self.obj = obj
        self.sentence = sentence

    def get(self):
        return self.sentence

class TaskTree:

    def __init__(self, local: AppSettings, game: Game, rep: RepData, rep_alias: str):
        self.local = local
        self.game = game
        self.rep = rep
        self.rep_alias = rep_alias

        self.items: List[Entry] = []
        self.index_selected = 0
        self.index_begin = 0
        self.max_title = 0
        self.search_text = ""
        self.load_from_rep()
        self.update_tree(admin_mode=Flags.admin.is_true())
        self.reload_sentences()

    def load_from_rep(self):
        self.new_items: List[str] = self.rep.get_new_items()
        self.expanded: List[str] = self.rep.get_expanded()
        self.index_selected = self.rep.get_index()

        tasks = self.rep.get_tasks()
        for key, serial in tasks.items():
            if key in self.game.tasks:
                self.game.tasks[key].load_from_db(serial)

    def save_on_rep(self):
        keys = self.game.available_clusters + self.game.available_quests
        expanded = [item for item in self.expanded if item in keys]
        self.rep.set_expanded(expanded)
        self.rep.set_new_items(self.new_items)
        self.rep.set_index(self.index_selected)
        tasks = {}
        for t in self.game.tasks.values():
            if not t.is_db_empty():
                tasks[t.key] = t.save_to_db()
        self.rep.set_tasks(tasks)


    def update_tree(self, admin_mode):
        if not admin_mode:
            old_reachable = self.game.available_clusters + self.game.available_quests

        self.game.update_reachable_and_available(admin_mode)
            
        if not admin_mode:
            available_keys = self.game.available_quests + self.game.available_clusters
            for key in self.expanded:
                if key not in available_keys:
                    self.expanded.remove(key)
                if key not in old_reachable:
                    self.new_items.append(key)

        # remove expanded items
        self.new_items = [item for item in self.new_items if item not in self.expanded]

    def update_max_title(self):
        items = []
        for c in self.game.clusters.values():
            if c.key in self.game.available_clusters:
                items.append(len(c.title))
                if c.key in self.expanded:
                    for q in [q for q in c.quests if q.key in self.game.available_quests]:
                        items.append(len(q.title) + 2)
                        if q.key in self.expanded:
                            for t in q.get_tasks():
                                items.append(len(t.title) + 6)
        self.max_title = max(items)

    def str_task(self, focus_color: str, t: Task, lig_cluster: str, lig_quest: str, quest_reachable: bool, min_value=1) -> Sentence:
        downloadable_in_focus = False
        rootdir = self.local.get_rootdir()
        down_symbol = Token(" ")
        in_focus = focus_color != ""
        down_symbol = symbols.cant_download
        rep_dir = os.path.join(self.local.get_rootdir(), self.rep_alias)
        if t.is_downloadable() and rootdir != "":
            if t.is_downloaded_for_lang(rep_dir, self.rep.get_lang()):
                down_symbol = symbols.downloaded
                if in_focus:
                    downloadable_in_focus = True
            else:
                down_symbol = symbols.to_download

        color_aval = "" if quest_reachable else "r"

        output = Sentence()
        output.add(" ").addf(color_aval, lig_cluster)
        output.add(" ")
        output.addf(color_aval, lig_quest)
        output.add(down_symbol)
        output.add(" ")
        output.add(t.get_grade_symbol(min_value))

        if in_focus:
            output.addf(focus_color.lower(), Style.roundL())
        else:
            output.add(" ")

        color = ""
        if in_focus:
            color = "k" + focus_color

        done = color + "g"
        todo = color
        perc = t.test_progress
        output.add(Style.build_bar(t.title, perc / 100, len(t.title), done, todo, round=False))
        # output.addf(color, t.title)

        if in_focus:
            output.addf(focus_color.lower(), Style.roundR())
        else:
            output.add(" ")


        if Flags.reward.is_true():
            xp = ""
            for s, v in t.skills.items():
                xp += f" +{s}:{v}"
            output.addf(Style.skills(), xp)
            
        return output

    def str_quest(self, has_kids: bool, focus_color: str, q: Quest, lig: str) -> Sentence:
        con = "━─"
        if q.key in self.expanded and has_kids:
            con = "─┯"

        color_reachable = "" if q.is_reachable() else "r"
        output: Sentence = Sentence().addf(color_reachable, " " + lig + con)

        in_focus = focus_color != ""
        if in_focus:
            output.addf(focus_color.lower(), Style.roundL())
        else:
            output.add(" ")

        color = ""
        if in_focus:
            color = "k" + focus_color

        title = q.title
        title = title.ljust(self.max_title - 2, ".")

        done = color + Style.prog_done()
        todo = color + Style.prog_todo()
        output.add(Style.build_bar(title, q.get_percent() / 100, len(title), done, todo, round=False))

        if in_focus:
            output.addf(focus_color.lower(), Style.roundR())
        else:
            output.add(" ")

        if Flags.percent.is_true():
            output.add(" ").add(q.get_resume_by_percent())
        else:
            output.add(" ").add(q.get_resume_by_tasks())

        if Flags.minimum.is_true():
            output.add(" ").add(q.get_requirement())

        if Flags.reward.is_true():
            xp = ""
            for s, v in q.skills.items():
                xp += f" +{s}:{v}"
            output.addf(Style.skills(), " " + xp)

        if q.key in self.new_items:
            output.addf(Style.new(), " [new]")

        return output


    def str_cluster(self, has_kids: bool, focus_color: str, cluster: Cluster) -> Sentence:
        output: Sentence = Sentence()
        opening = "━─"
        if cluster.key in self.expanded and has_kids:
            opening = "─┯"
        color_reachable = "" if cluster.is_reachable() else "r"
        output.addf(color_reachable, opening)

        color = ""
        if focus_color != "":
            color = "k" + focus_color
        title = cluster.title

        title = cluster.title.ljust(self.max_title, ".")
        if focus_color != "":
            output.addf(focus_color.lower(), Style.roundL())
        else:
            output.add(" ")

        done = color + Style.prog_done()
        todo = color + Style.prog_todo()

        output.add(Style.build_bar(title, cluster.get_percent() / 100, len(title), done, todo, round=False))

        if focus_color != "":
            output.addf(focus_color.lower(), Style.roundR())
        else:
            output.add(" ")


        if Flags.percent.is_true():
            output.add(" ").add(cluster.get_resume_by_percent())
        else:
            output.add(" ").add(cluster.get_resume_by_quests())
        if cluster.key in self.new_items:
            output.addf(Style.new(), " [new]")

        return output


    # def add_in_search(self, item: Any, sentence: Sentence) -> bool:
    #     if self.search_text == "":
    #         self.items.append(Entry(item, sentence))
    #         return True
        
    #     matcher = SearchAsc(self.search_text)
    #     pos = matcher.find(sentence.get_text())
    #     found = pos != -1
    #     if found:
    #         for i in range(pos, pos + len(self.search_text)):
    #             sentence.data[i].fmt = "Y"

    #     if isinstance(item, Task):
    #         if found:
    #             self.items.append(Entry(item, sentence))
    #             return True
    #     elif isinstance(item, Quest):
    #         if found:
    #             self.items.append(Entry(item, sentence))
    #             return True
    #         for t in item.get_tasks():
    #             if matcher.inside(t.title):
    #                 self.items.append(Entry(item, sentence))
    #                 return True
    #     elif isinstance(item, Cluster):
    #         cluster: Cluster = item
    #         if matcher.inside(cluster.title):
    #             self.items.append(Entry(cluster, sentence))
    #             return True
    #         for q in cluster.quests:
    #             if matcher.inside(q.title):
    #                 self.items.append(Entry(item, sentence))
    #                 return True
    #             for t in q.get_tasks():
    #                 if matcher.inside(t.title):
    #                     self.items.append(Entry(item, sentence))
    #                     return True
    #     return False

    def get_focus_color(self, item: Union[Quest, Cluster], index: int) -> str:
        if index != self.index_selected:
            return ""
        if not item.is_reachable() and not Flags.admin.is_true():
            return "R"
        return Style.focus()

    def filter_by_search(self) -> Set[str]:
        matches: Set[str] = set()
        search = SearchAsc(self.search_text)
        for cluster in self.game.clusters.values():
            if search.inside(cluster.title):
                matches.add(cluster.key)
            for quest in cluster.quests:
                if search.inside(quest.title):
                    matches.add(cluster.key)
                    matches.add(quest.key)
                for task in quest.get_tasks():
                    if search.inside(task.title):
                        matches.add(cluster.key)
                        matches.add(quest.key)
                        matches.add(task.key)
        return matches

    def try_add(self, filtered, matcher, item, sentence):
        if self.search_text == "":
            self.items.append(Entry(item, sentence))
            return True
        if item.key in filtered:
            pos = matcher.find(sentence.get_text())
            found = pos != -1
            if found:
                for i in range(pos, pos + len(self.search_text)):
                    sentence.data[i].fmt = "Y"
            self.items.append(Entry(item, sentence))
            return True
        return False

    def reload_sentences(self):
        self.update_max_title()
        index = 0
        self.items = []
        available_quests = self.game.available_quests
        available_clusters = self.game.available_clusters

        filtered = self.filter_by_search()
        matcher = SearchAsc(self.search_text)

        clusters = [self.game.clusters[key] for key in available_clusters if key in filtered]
        for cluster in clusters:
            quests = [q for q in cluster.quests if q.key in available_quests if q.key in filtered]
            focus_color = self.get_focus_color(cluster, index)
            sentence = self.str_cluster(len(quests) > 0, focus_color, cluster)

            if self.try_add(filtered, matcher, cluster, sentence):
                index += 1

            if cluster.key not in self.expanded:  # adicionou o cluster, mas não adicione as quests
                continue

            for q in quests:
                tasks =[t for t in q.get_tasks() if t.key in filtered]
                lig = "├" if q != quests[-1] else "╰"
                focus_color = self.get_focus_color(q, index)
                sentence = self.str_quest(len(tasks) > 0, focus_color, q, lig)

                # self.items.append(Entry(q, sentence))
                if self.try_add(filtered, matcher, q, sentence):
                    index += 1
                if q.key in self.expanded:
                    for t in tasks:
                        ligc = "│" if q != quests[-1] else " "
                        ligq = "├ " if t != tasks[-1] else "╰ "
                        min_value = 7 if q.tmin is None else q.tmin
                        focus_color = self.get_focus_color(q, index)
                        sentence = self.str_task(focus_color, t, ligc, ligq, q.is_reachable(), min_value)
                        if self.try_add(filtered, matcher, t, sentence):
                            index += 1

        if self.index_selected >= len(self.items):
            self.index_selected = len(self.items) - 1


    def process_collapse(self):
        if any([q in self.expanded for q in self.game.available_quests]):
            self.expanded = [key for key in self.expanded if key not in self.game.available_quests]
        else:
            self.expanded = []

    def process_expand(self):
        # if any cluster outside expanded
        expand_clusters = False
        for ckey in self.game.available_clusters:
            if ckey not in self.expanded:
                expand_clusters = True
        if expand_clusters:
            for ckey in self.game.available_clusters:
                if ckey not in self.expanded:
                    self.expanded.append(ckey)
        else:
            for qkey in self.game.available_quests:
                if qkey not in self.expanded:
                    self.expanded.append(qkey)


    def mass_mark(self):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Cluster):
            cluster: Cluster = obj
            if cluster.key not in self.expanded:
                self.expanded.append(cluster.key)
                return
            full_open = True
            for q in cluster.quests:
                if q.key in self.game.available_quests and q.key not in self.expanded:
                    self.expanded.append(q.key)
                    full_open = False
            if not full_open:
                return

            value = None
            for q in obj.quests:
                for t in q.get_tasks():
                    if value is not None:
                        t.set_grade(value)
                    else:
                        value = 10 if t.grade < 10 else 0
                        t.set_grade(value)
        elif isinstance(obj, Quest):
            if obj.key not in self.expanded:
                self.expanded.append(obj.key)
            else:
                value = None
                for t in obj.get_tasks():
                    if value is not None:
                        t.set_grade(value)
                    else:
                        value = 10 if t.grade < 10 else 0
                        t.set_grade(value)
        else:
            obj.set_grade(10 if obj.grade < 10 else 0)

    def set_grade(self, grade: int):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Task):
            obj.set_grade(grade)

    def inc_grade(self):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Task):
            grade = obj.grade + 1
            if grade == 11:
                grade = 10
            obj.set_grade(grade)
        else:
            self.unfold(obj)

    
    def dec_grade(self):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Task):
            grade = obj.grade - 1
            if grade == -1:
                grade = 0
            obj.set_grade(grade)
        else:
            self.fold(obj)

    def arrow_right(self):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Cluster):
            if not self.unfold(obj):
                self.index_selected += 1
        elif isinstance(obj, Quest):
            if not self.unfold(obj):
                while True:
                    self.index_selected += 1
                    obj = self.items[self.index_selected].obj
                    if isinstance(obj, Cluster) or isinstance(obj, Quest):
                        break
                    if self.index_selected == len(self.items) - 1:
                        break
        elif isinstance(obj, Task):
            while True:
                obj = self.items[self.index_selected].obj
                if isinstance(obj, Quest) or isinstance(obj, Cluster):
                    break
                if self.index_selected == len(self.items) - 1:
                    break
                self.index_selected += 1

    def arrow_left(self):
        obj = self.items[self.index_selected].obj
        if isinstance(obj, Quest):
            if not self.fold(obj):
                while True:
                    if self.index_selected == 0:
                        break
                    self.index_selected -= 1
                    obj = self.items[self.index_selected].obj
                    if isinstance(obj, Cluster) or isinstance(obj, Quest) and obj.key in self.expanded:
                        break
                    if self.index_selected == 0:
                        break
        elif isinstance(obj, Cluster):
            if obj.key in self.expanded:
                self.expanded.remove(obj.key)
                for q in obj.quests:
                    try:
                        self.expanded.remove(q.key)
                    except ValueError:
                        pass
            else:
                while True:
                    if self.index_selected == 0:
                        break
                    self.index_selected -= 1
                    obj = self.items[self.index_selected].obj
                    if isinstance(obj, Cluster) or isinstance(obj, Quest):
                        break
                    if self.index_selected == 0:
                        break
        elif isinstance(obj, Task):
            while True:
                obj = self.items[self.index_selected].obj
                if isinstance(obj, Quest):
                    break
                self.index_selected -= 1

    def unfold(self, obj: Union[Task, Quest, Cluster]) -> bool:
        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            if obj.key not in self.expanded:
                self.expanded.append(obj.key)
                return True
        return False

    def fold(self, obj: Union[Task, Quest, Cluster]) -> bool:
        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            if obj.key in self.expanded:
                self.expanded.remove(obj.key)
                return True
        return False

    def toggle(self, obj: Union[Quest, Cluster]):
            if not self.fold(obj):
                self.unfold(obj)

    def get_senteces(self, dy):
        if len(self.items) < dy:
            self.index_begin = 0
        else:
            if self.index_selected < self.index_begin:  # subiu na tela
                self.index_begin = self.index_selected
            elif self.index_selected >= dy + self.index_begin:  # desceu na tela
                self.index_begin = self.index_selected - dy + 1

        sentences: List[Sentence] = []
        for i in range(self.index_begin, len(self.items)):
            sentences.append(self.items[i].sentence)
        return sentences

    def get_selected(self):
        return self.items[self.index_selected].obj

    def move_up(self):
        self.index_selected = max(0, self.index_selected - 1)

    def move_down(self):
        self.index_selected = min(len(self.items) - 1, self.index_selected + 1)


class Opener:
    def __init__(self, tree: TaskTree, fman: FloatingManager, geral: AppSettings, rep_data: RepData, rep_alias: str):
        self.tree = tree
        self.fman = fman
        self.geral = geral
        self.rep = rep_data
        self.rep_alias = rep_alias

    def set_fman(self, fman: FloatingManager):
        self.fman = fman
        return self

    def get_task_readme_path(self) -> str:
        obj = self.tree.get_selected()
        if isinstance(obj, Task):
            rootdir = self.geral.get_rootdir()
            if rootdir != "":
                path = os.path.join(self.geral.get_rootdir(), self.rep_alias, obj.key, "Readme.md")
                if os.path.isfile(path):
                    return path
        return ""

    def open_code(self, open_drafts: bool=False, open_readme: bool=False, open_dir: bool = False, open_cases: bool = False):
        obj = self.tree.get_selected()
        if isinstance(obj, Task):
            path = self.get_task_readme_path()
            cmd = self.geral.get_editor()
            # code, _, _ = Runner().subprocess_run("whereis {}".format(cmd))
            if not os.path.isfile(path):
                if open_readme:
                    self.fman.add_input(
                        Floating("v>").error().put_text("Não achei nada baixado para você ler.")
                    )
                if open_drafts:
                    self.fman.add_input(
                        Floating("v>").error().put_text("Não achei nada baixado para você editar.")
                    )
                if open_dir:
                    self.fman.add_input(
                        Floating("v>").error().put_text("Não achei nada baixado para você abrir.")
                    )
                return
            if open_dir:
                # code, out, err = Runner.subprocess_run(f"{cmd} -h")
                # if ("Replit" in out) or ("replit" in err):
                open_cases = True
                open_readme = True
                open_drafts = True
                # else:
                #     outfile = tempfile.NamedTemporaryFile(delete=False)
                #     self.fman.add_input(
                #         Floating("v>")
                #             .warning()
                #             .put_text("Abrindo arquivos do problema com o comando")
                #             .put_sentence(Sentence().addf("g", f"  {cmd}"))
                #     )
                #     subprocess.Popen(f"{cmd} {os.path.dirname(path)}", stdout=outfile, shell=True)
                #     #code, out, err = Runner.subprocess_run(f"{cmd} {os.path.dirname(path)}")
                
            files_to_open: List[str] = []
            if open_readme:
                files_to_open.append(path)
                # Runner.subprocess_run(f"{cmd} {path}")
            if open_cases:
                cases = os.path.join(os.path.dirname(path), "cases.tio")
                if os.path.isfile(cases):
                    files_to_open.append(cases)
                    # Runner.subprocess_run(f"{cmd} {cases}")
            folder = os.path.dirname(path)
            files = os.listdir(folder)
            if open_drafts:
                drafts = []
                for f in files:
                    allowed = [self.rep.get_lang()]
                    if self.rep.get_lang() == "c" or self.rep.get_lang() == "cpp":
                        allowed.append("h")
                        allowed.append("hpp")
                    if not f.endswith(tuple(allowed)):
                        continue
                    drafts.append(os.path.join(folder, f))
                if len(drafts) == 0:
                    self.fman.add_input(
                        Floating("v>").error().put_text("Não achei nenhum arquivo de rascunho.")
                    )
                    return
                for f in drafts:
                    files_to_open.append(f)
            if len(files_to_open) != 0:
                # print(" ".join(files_to_open))
                # Runner.subprocess_run("{} {}".format(cmd, " ".join(files_to_open)))
                aviso = (Floating("v>")
                        .warning()
                        .put_text("Abrindo arquivos do problema com o comando")
                        .put_sentence(Sentence().addf("g", f"{cmd}"))
                        )
                files = [os.path.basename(path) for path in files_to_open]
                aviso.put_sentence(Sentence().addf("g", " ".join(files)))
                self.fman.add_input(aviso)
                fullcmd = "{} {}".format(cmd, " ".join(files_to_open))
                outfile = tempfile.NamedTemporaryFile(delete=False)
                subprocess.Popen(fullcmd, stdout=outfile, stderr=outfile, shell=True)


class Mode(enum.Enum):
    intro = 0
    select = 1
    running = 2
    finished = 3


class DActions:
    sair   = "  Sair"
    editar = "Editar"
    testar = "Ativar"
    rodar  = " Rodar"
    principal = "Principal"
    fixar  = " Fixar"
    tempo = "Tempo"
    outros = "Outros"

class DKeys:
    backspace1 = 127
    left = "a"
    up = "w"
    right = "d"
    down = "s"
    principal = "p"
    diff = "m"
    rodar = "r"
    testar = "\n"
    # testar2 = "\n"
    sair   = "q"
    editar = "e"
    travar = "f"
    tempo  = "t"
    outros = "o"

class CDiff:
    def __init__(self, wdir: Wdir, param: Param.Basic, success_type: Success):
        self.param = param
        self.results: List[Tuple[ExecutionResult, int]] = []
        self.wdir = wdir
        self.unit_list = [unit for unit in wdir.get_unit_list()] # unit list to be consumed
        self.exit = False
        self.success_type = success_type
        self.task = Task()
        self.init = 1000   # index of first line to show
        self.length = 1  # length of diff
        self.space = 0  # dy space for draw
        self.mode: Mode = Mode.intro

        self.locked_index: bool = False

        self.focused_index = 0
        self.finished = False
        self.resumes: List[str] = []

        self.settings = Settings()
        self.colors = self.settings.app.is_colored()
        self.first_loop = True
        self.fman = FloatingManager()
        self.first_run = False

        self.opener: Optional[Opener] = None

    def set_first_run(self):
        self.first_run = True
        return self

    def set_opener(self, opener: Opener):
        self.opener = opener
        self.opener.set_fman(self.fman)
        return self

    def set_autorun(self, value:bool):
        if value:
            self.mode = Mode.running
        return self

    def save_settings(self):
        self.settings.app.set_diff_mode("down" if self.param.is_up_down else "side")
        self.settings.save_settings()
        return self
    
    def set_task(self, task: Task):
        self.task = task
        return self

    def set_exit(self):
        self.exit = True
        return self

    def print_centered_image(self, image: str, color: str, clear=False, align: str = "."):
        dy, dx = Fmt.get_size()
        lines = image.split("\n")[1:]
        init_y = 3
        if align == "v":
            init_y = dy - len(lines) - 1
        for i, line in enumerate(lines):
            info = Sentence().addf(color, line).center(dx - 2, Token(" ", " "))
            if clear:
                Fmt.write(i + init_y, 1, Sentence(" " * info.len()))
            else:
                Fmt.write(i + init_y, 1, Sentence().addf(color, line).center(dx - 2, Token(" ", " ")))

    def show_success(self):
        if self.success_type == Success.RANDOM:
            out = random_get(images, self.get_folder(), "static")
        else:
            out = random_get(success, self.get_folder(), "static")
        self.print_centered_image(out, "" if not self.colors else "g")
        
    def show_compilling(self, clear=False):
        out = random_get(compilling, self.get_folder(), "random")
        self.print_centered_image(out, "" if not self.colors else "y", clear)

    def show_executing(self, clear=False):
        out = executing
        self.print_centered_image(out, "" if not self.colors else "y", clear, "v")

    def draw_scrollbar(self):
        y_init = 3
        # if len(self.results_fail) == 0:
        #     return
        tr = "╮"
        br = "╯"
        vbar = "│"
        bar = []

        if self.length > self.space:
            total = self.space
            _begin = False
            _end = False
            if self.init == 0:
                _begin = True
            if self.init == self.length - self.space:
                _end = True

            pre = int((self.init / self.length) * total)
            mid = int((self.space / self.length) * total)
            pos = (max(0, total - pre - mid))

            if _begin:
                pre -= 1
            if _end:
                pos -= 1

            if self.init > 0 and pre == 0:
                pre = 1
                pos -= 1

            if _begin:
                bar.append(tr)
            for _ in range(pre):
                bar.append(vbar)
            for _ in range(mid):
                bar.append("┃")
            for _ in range(pos):
                bar.append(vbar)
            if _end:
                bar.append(br)

        else:
            bar.append(tr)
            for i in range(self.length - 2):
                bar.append(vbar)
            bar.append(br)


        _, cols = Fmt.get_size()
        for i in range(len(bar)):
            Fmt.write(i + y_init, cols - 1, Sentence().add(bar[i]))

    def get_folder(self):
        source_list = self.wdir.get_source_list()
        if source_list:
            folder = os.path.abspath(source_list[0])
        else:
            folder = os.path.abspath(self.wdir.get_solver().path_list[0])
        return folder.split(os.sep)[-2]

    def get_focused_unit(self) -> Unit:
        if len(self.results) != 0:
            _, index = self.results[self.focused_index]
            unit = self.wdir.get_unit(index)
            return unit
        return self.wdir.get_unit(self.focused_index)

    def get_token(self, result: ExecutionResult) -> Token:
        if result == ExecutionResult.SUCCESS:
            return Token(ExecutionResult.get_symbol(ExecutionResult.SUCCESS).text, "G")
        elif result == ExecutionResult.WRONG_OUTPUT:
            return Token(ExecutionResult.get_symbol(ExecutionResult.WRONG_OUTPUT).text, "R")
        elif result == ExecutionResult.COMPILATION_ERROR:
            return Token(ExecutionResult.get_symbol(ExecutionResult.UNTESTED).text, "W")
        elif result == ExecutionResult.EXECUTION_ERROR:
            return Token(ExecutionResult.get_symbol(ExecutionResult.EXECUTION_ERROR).text, "Y")
        else:
            return Token(ExecutionResult.get_symbol(ExecutionResult.UNTESTED).text, "W")

    def process_one(self):

        if self.mode != Mode.running:
            return

        solver = self.wdir.get_solver()

        if solver.compile_error:
            self.mode = Mode.finished
            while len(self.unit_list) > 0:
                index = len(self.results)
                self.unit_list = self.unit_list[1:]
                self.results.append((ExecutionResult.COMPILATION_ERROR, index))
            return
        
        if self.locked_index:
            self.mode = Mode.finished
            unit = self.get_focused_unit()
            unit.result = Execution.run_unit(solver, unit, self.settings.app.get_timeout())
            return

        if len(self.unit_list) > 0:
            index = len(self.results)
            unit = self.unit_list[0]
            self.unit_list = self.unit_list[1:]
            unit.result = Execution.run_unit(solver, unit, self.settings.app.get_timeout())
            self.results.append((unit.result, index))
            success = [result for result, _ in self.results if result == ExecutionResult.SUCCESS]
            self.task.test_progress = (len(success) * 100) // len(self.wdir.get_unit_list())
            self.focused_index = index

        if len(self.unit_list) == 0:
            self.mode = Mode.finished
            self.focused_index = 0


            done_list: List[Tuple[ExecutionResult, int]] = []
            fail_list: List[Tuple[ExecutionResult, int]] = []
            for data in self.results:
                unit_result, _ = data
                if unit_result != ExecutionResult.SUCCESS:
                    fail_list.append(data)
                else:
                    done_list.append(data)
            self.results = fail_list + done_list


    def build_top_line_header(self, frame):
        activity_color = "W" if not self.colors else "C"
        solver_color = "M" if not self.colors else "M"
        sources_color = "W" if not self.colors else "Y"
        running_color = "W" if not self.colors else "R"

        # building activity
        activity = Sentence().add(Style.border_round(activity_color, self.get_folder()))

        # building solvers
        solvers = Sentence()
        if len(self.get_solver_names()) > 1:
            solvers.add(Style.border_sharp("W", "[p]"))
        for i, solver in enumerate(self.get_solver_names()):
            color = solver_color
            if i == self.task.main_index:
                color = "G"
            solvers.add(Style.border_round(color, solver))
        
        # replacing with count if running
        done = len(self.results)
        full = len(self.wdir.get_unit_list())
        count_missing = Sentence().add(Style.border_round(running_color, f"({done}/{full})"))
        if self.mode == Mode.running:
            if  self.locked_index:
                solvers = Sentence().add(Style.border_round("R", "Executando atividade travada"))
            else:
                solvers = count_missing

        # building sources
        source_names = Sentence(", ").join([Sentence().addf(sources_color, f"{name[0]}({name[1]})") for name in self.wdir.sources_names()])
        sources = Sentence().addf(sources_color.lower(), Style.roundL()).add(source_names).addf(sources_color.lower(), Style.roundR())

        # merging activity, solvers and sources in header
        delta = frame.get_dx() - solvers.len()
        left = 1
        right = 1
        if delta > 0:
            delta_left = delta // 2
            left = max(1, delta_left - activity.len())
            delta_right = delta - delta_left
            right = max(1, delta_right - sources.len())

        return Sentence().add(activity).add("─" * left).add(solvers).add("─" * right).add(sources)

    def build_top_bar_footer(self, frame):
        output = Sentence()
        done_list = self.results
        if len(done_list) > 0 and self.locked_index:
            _, index = done_list[self.focused_index]
            done_list[self.focused_index] = (self.get_focused_unit().result, index)
        todo_list: List[Tuple[ExecutionResult, int]] = []
        i = len(done_list)
        for _ in self.unit_list:
            if self.locked_index and i == self.focused_index:
                todo_list.append((self.wdir.get_unit(self.focused_index).result, i))
            else:
                todo_list.append((ExecutionResult.UNTESTED, i))
            i += 1

        i = 0
        show_focused_index = not self.wdir.get_solver().compile_error and not self.mode == Mode.intro and not self.is_all_right()
        for unit_result, index in done_list + todo_list:
            foco = i == self.focused_index
            token = self.get_token(unit_result)
            extrap = Token(Style.roundL(), token.fmt.lower())# if not foco else Token(Style.roundL(), "")
            extras = Token(Style.roundR(), token.fmt.lower())# if not foco else Token(Style.roundR(), "")
            if foco and show_focused_index:
                token.fmt = ""
            output.add(extrap).addf(token.fmt, str(index).zfill(2)).add(token).add(extras).add(" ")
            i += 1

        size = 6
        if self.focused_index * size > frame.get_dx():
            output.cut_begin((self.focused_index + 1) * size - frame.get_dx())
        return output

    def draw_top_bar_content(self, frame):
        focused_unit_color = "B"
        value = self.get_focused_unit()
        info = Sentence()
        if self.wdir.get_solver().compile_error:
            info = Style.border_round("R", "Erro de compilação")
        elif value is not None and not self.is_all_right() and not self.mode == Mode.intro:
            info = value.str(pad = False)
            if self.locked_index:
                info = Style.border_round(focused_unit_color, info.get_text())
        frame.write(0, 0, Sentence().add(info).center(frame.get_dx()))

    def draw_top_bar(self):
        # construir mais uma solução
        _, cols = Fmt.get_size()
        frame = Frame(0, 0).set_size(3, cols)
        frame.set_header(self.build_top_line_header(frame))

        self.draw_top_bar_content(frame)
    
        frame.set_footer(self.build_top_bar_footer(frame), "")
        frame.draw()
        
    def two_column_mode(self):
        _, cols = Fmt.get_size()
        return cols < Sentence(" ").join(self.make_bottom_line()).len() + 2

    def make_bottom_line(self) -> List[Sentence]:
        cmds: List[Sentence] = []
        if Flags.others.is_true():
            cmds.append(Style.border_round("M", f"{DActions.rodar}[{DKeys.rodar}]"))
            # diff
            text = f"VER━╾h[{DKeys.diff}]" if self.settings.app.get_diff_mode() == "side" else f"v╼━HOR[{DKeys.diff}]"
            cmds.append(Style.border_round("M", text))
        
        cmds.append(Style.border_round("C", f"{DActions.sair}[{DKeys.sair}]"))
        if self.opener is not None:
            cmds.append(Style.border_round("C", f"{DActions.editar}[{DKeys.editar}]"))
        cmds.append(Style.border_round("G", f"{DActions.testar}[↲]"))
        
        color = "G" if Flags.others.is_true() else "Y"
        cmds.append(Style.border_sharp(color, f"{DActions.outros}[{DKeys.outros}]"))
        if Flags.others.is_true():
            # travar

            value = str(self.settings.app.get_timeout())
            if value == "0":
                value = "∞"
            cmds.append(
                Sentence()
                    .addf("m", Style.roundL())
                    .add(RToken("M", f"{DActions.tempo}"))
                    .add(RToken("M", "{}".format(value)))
                    .add(RToken("M", f"[{DKeys.tempo}]"))
                    .addf("m", Style.roundR())
            )
            travar = f"{DActions.fixar}[{DKeys.travar}]"
            color = "G" if self.locked_index else "M"
            cmds.append(Style.border_sharp(color, travar))


        return cmds

    def show_bottom_line(self):
        lines, cols = Fmt.get_size()
        if self.two_column_mode():
            line = self.make_bottom_line()
            one = line[0:2] + line[-2:]
            two = line[2:-2]
            Fmt.write(lines - 2, 0, Sentence(" ").join(one).center(cols, Token(" ")))
            Fmt.write(lines - 1, 0, Sentence(" ").join(two).center(cols, Token(" ")))
        else:
            out = Sentence(" ").join(self.make_bottom_line())
            # if Fmt.get_size()[1] % 2 == 0:
            #     out.add("-")
            Fmt.write(lines - 1, 0, out.center(cols, Token(" ")))
 
    def is_all_right(self):
        if self.locked_index or len(self.results) == 0:
            return False
        if not self.mode == Mode.finished:
            return False
        for result, _ in self.results:
            if result != ExecutionResult.SUCCESS:
                return False
        return True

    def draw_main(self):
        unit = self.get_focused_unit()
        lines, cols = Fmt.get_size()
        self.space = lines - 4
        if self.two_column_mode():
            self.space = lines - 5
        frame = Frame(2, -1).set_inner(self.space, cols - 1).set_border_square()

        if self.is_all_right():
            self.show_success()
            return
        Report.set_terminal_size(cols)
        
        if self.wdir.get_solver().compile_error:
            received = self.wdir.get_solver().error_msg
            line_list = [Sentence().add(line) for line in received.split("\n")]
        elif self.param.is_up_down:
            line_list = Diff.mount_up_down_diff(unit, curses=True)
        else:
            line_list = Diff.mount_side_by_side_diff(unit, curses=True)

        self.length = max(1, len(line_list))

        if self.length - self.init < self.space:
            self.init = max(0, self.length - self.space)

        if self.init >= self.length:
            self.init = self.length - 1

        if self.init < self.length:
            line_list = line_list[self.init:]
        for i, line in enumerate(line_list):
            frame.write(i, 0, Sentence().add(line))

        self.draw_scrollbar()
        return

    def load_autoload_warning(self):
        if not self.wdir.is_autoload():
            return
        warning = Floating().set_header(" Seja bem vindo ").warning()
        warning.put_text("")
        warning.put_sentence(Sentence().addf("r", "Todos") + " os arquivos de código da pasta foram carregados automaticamente")
        warning.put_text("Sempre verifique no topo da tela quais arquivos foram carregados.")
        warning.put_text("Remova ou renomeie da pasta alvo os arquivo que não quer utilizar.")
        warning.put_text("")
        warning.put_text("Você também pode escolher quais arquivos deseja executar")
        warning.put_text("navegando até a pasta de destino e executando")
        warning.put_text("o comando 'tko run' com os arquivos desejados")
        warning.put_text("")
        warning.put_sentence(Sentence().addf("c", "tko run <arquivos> cases.tio")) 
        warning.put_text("")
        warning.put_sentence(Sentence().addf("r", "Exemplo: ").addf("c", "tko run main.c lib.c cases.tio")) 
        warning.put_text("")

        self.fman.add_input(warning)

    def get_solver_names(self):
        return sorted(self.wdir.solvers_names())
    
    def main(self, scr):
        curses.curs_set(0)  # Esconde o cursor
        Fmt.init_colors()  # Inicializa as cores
        Fmt.set_scr(scr)  # Define o scr como global
        while not self.exit:
            if self.first_loop and self.first_run:
                self.first_loop = False
                self.load_autoload_warning()
            Fmt.clear()
            if self.mode == Mode.running:
                if self.wdir.get_solver().not_compiled():
                    self.draw_top_bar()
                    self.show_bottom_line()
                    self.show_compilling()
                    Fmt.refresh()
                    try:
                        self.wdir.get_solver().prepare_exec()
                    except CompileError as e:
                        self.fman.add_input(Floating("v>").error().put_text(e.message))
                        self.mode = Mode.finished
                    Fmt.clear()
                    self.draw_top_bar()
                    self.show_bottom_line()
                    Fmt.refresh()
                self.process_one()
            self.draw_top_bar()

            if self.mode == Mode.intro:
                self.print_centered_image(random_get(intro, self.get_folder()), "y")
            else:
                self.draw_main()
            
            self.show_bottom_line()

            if self.fman.has_floating():
                self.fman.draw_warnings()

            if self.mode == Mode.running:
                Fmt.refresh()
                continue

            if self.fman.has_floating():
                key = self.fman.get_input()
            else:
                key = Fmt.getch()

            fn_exec = self.process_key(key)
            if fn_exec is not None:
                return fn_exec

    def run_exec_mode(self):
        self.mode = Mode.running
        if self.wdir.is_autoload():
            self.wdir.autoload()
            self.wdir.get_solver().set_main(self.get_solver_names()[self.task.main_index])
        return lambda: Free.free_run(self.wdir.get_solver(), show_compilling=True, to_clear=True, wait_input=True)

    def run_test_mode(self):
        self.mode = Mode.running
        if self.wdir.is_autoload():
            self.wdir.autoload() # reload sources and solvers
        
        self.wdir.build() # reload cases

        Fmt.clear()
        self.wdir.get_solver().set_main(self.get_solver_names()[self.task.main_index]).reset() # clear old compilation
        
        if self.locked_index:
            for i in range(len(self.results)):
                _, index = self.results[i]
                self.results[i] = (ExecutionResult.UNTESTED, index)
        else:
            self.focused_index = 0
            self.results = []
            self.unit_list = [unit for unit in self.wdir.get_unit_list()]

    def send_char_not_found(self, key):
        self.fman.add_input(Floating("v>").error()
                    .put_text("Tecla")
                    .put_text(f"char {chr(key)}")
                    .put_text(f"code {key}")
                    .put_text("não reconhecida")
                    .put_text("")
                    )

    def go_left(self):
        if self.mode == Mode.intro:
            self.mode = Mode.select
        if self.locked_index:
            self.fman.add_input(Floating("v>").warning().put_text("←\nAtividade travada\nAperte {} para destravar".format(DKeys.travar)))
            return
        if not self.wdir.get_solver().compile_error:
            self.focused_index = max(0, self.focused_index - 1)
            self.init = 1000

    def go_right(self):
        if self.mode == Mode.intro:
            self.mode = Mode.select
            self.focused_index = 0
            return
        if self.locked_index:
            self.fman.add_input(Floating("v>").warning().put_text("→\nAtividade travada\nAperte {} para destravar".format(DKeys.travar)))
            return
        if not self.wdir.get_solver().compile_error:
            self.focused_index = min(len(self.wdir.get_unit_list()) - 1, self.focused_index + 1)
            self.init = 1000

    def go_down(self):
        if self.mode == Mode.intro:
            self.mode = Mode.select
        self.init += 1

    def go_up(self):
        if self.mode == Mode.intro:
            self.mode = Mode.select
        self.init = max(0, self.init - 1)

    def change_main(self):
        if len(self.get_solver_names()) == 1:
            self.fman.add_input(
                Floating("v>").warning()
                .put_text("Seu projeto só tem um arquivo de solução")
                .put_text("Essa funcionalidade troca qual dos arquivos")
                .put_text("de solução será o principal.")
            )
            return
        self.task.main_index = (self.task.main_index + 1) % len(self.get_solver_names())

    def lock_unit(self):
        self.locked_index = not self.locked_index
        if self.mode == Mode.intro:
            self.mode = Mode.select
        if self.locked_index:
            for i in range(len(self.results)):
                _, index = self.results[i]
                self.results[i] = (ExecutionResult.UNTESTED, index)
            self.fman.add_input(
                Floating("v>").warning()
                .put_text("Atividade travada")
                .put_sentence(Sentence("Aperte ").addf("g", DKeys.travar).add(" para destravar"))
                .put_sentence(Sentence("Use ").addf("g", "Enter").add(" para rodar os testes"))
            )

    def change_limit(self):
            valor = self.settings.app.get_timeout()
            if valor == 0:
                valor = 1
            else:
                valor *= 2
            if valor >= 5:
                valor = 0
            self.settings.app.set_timeout(valor)
            self.save_settings()
            nome = "∞" if valor == 0 else str(valor)
            self.fman.add_input(
                Floating("v>").warning()
                .put_text("Limite de tempo de execução alterado para")
                .put_text(f"{nome} segundos")
            )

    def process_key(self, key):
        key_esc = 27
        if key == ord('q') or key == key_esc or key == DKeys.backspace1:
            self.set_exit()
        elif key == curses.KEY_LEFT or key == ord(DKeys.left):
            self.go_left()
        elif key == curses.KEY_RIGHT or key == ord(DKeys.right):
            self.go_right()
        elif key == curses.KEY_DOWN or key == ord(DKeys.down):
            self.go_down()
        elif key == curses.KEY_UP or key == ord(DKeys.up):
            self.go_up()
        elif key == ord(DKeys.diff):
            self.param.is_up_down = not self.param.is_up_down
            self.save_settings()
            # self.init = 0
        elif key == ord(DKeys.principal):
            self.change_main()
        elif key == ord(DKeys.rodar):
            return self.run_exec_mode()
        elif key == ord(DKeys.testar):
            self.run_test_mode()
        elif key == ord(DKeys.travar):
            self.lock_unit()
        elif key == ord(DKeys.editar):
            if self.opener is not None:
                self.opener.open_code(open_dir=True)
        elif key == ord(DKeys.tempo):
            self.change_limit()
        elif key == ord(DKeys.outros):
            Flags.others.toggle()
        elif key != -1 and key != curses.KEY_RESIZE:
            self.send_char_not_found(key)

    def run(self):
        while True:
            free_run_fn = curses.wrapper(self.main)
            if free_run_fn == None:
                break
            else:
                while(free_run_fn()):
                    pass






class FilterMode:

    @staticmethod
    def deep_copy_and_change_dir():
        # path to ~/.tko_filter
        filter_path = os.path.join(os.path.expanduser("~"), ".tko_filter")

        # verify if filter command is available
        if shutil.which("filter_code") is None:
            print("ERROR: comando de filtragem não encontrado")
            print("Instale o feno com 'pip install feno'")
            exit(1)

        subprocess.run(["filter_code", "-rf", ".", "-o", filter_path])

        os.chdir(filter_path)


class Run:

    def __init__(self, target_list: List[str], exec_cmd: Optional[str], param: Param.Basic):
        self.target_list: List[str] = target_list
        self.exec_cmd: Optional[str] = exec_cmd
        self.param: Param.Basic = param
        self.wdir: Wdir = Wdir()
        self.wdir_builded = False
        self.__curses_mode: bool = False
        self.__first_run = False
        self.__success_mode = Success.RANDOM
        # self.__curses_select_mode = False
        self.__lang = ""
        self.__task: Optional[Task] = None
        self.__opener: Optional[Opener] = None
        self.__autorun: bool = True

    def set_curses(self, value:bool=True, success: Success=Success.RANDOM):
        self.__curses_mode = value
        self.__success_mode = success
        return self
   
    def set_lang(self, lang:str):
        self.__lang = lang
        return self
    
    def set_opener(self, opener: Opener):
        self.__opener = opener
        return self

    def set_autorun(self, value:bool):
        self.__autorun = value

    # def set_curses_select_mode(self, value:bool=True):
    #     self.__curses_select_mode = value
    #     return self
    
    def set_task(self, task: Task):
        self.__task = task
        return self

    def set_first_run(self):
        self.__first_run = True
        return self
    
    def execute(self):
        if not self.wdir_builded:
            self.build_wdir()

        if self.__missing_target():
            return
        if self.__list_mode():
            return
        if self.__free_run():
            return
        self.__diff_mode()
        return

    def __remove_duplicates(self):
        # remove duplicates in target list keeping the order
        self.target_list = list(dict.fromkeys(self.target_list))

    def __change_targets_to_filter_mode(self):
        if self.param.filter:
            old_dir = os.getcwd()

            term_print(Report.centralize(" Entrando no modo de filtragem ", "═"))
            FilterMode.deep_copy_and_change_dir()  
            # search for target outside . dir and redirect target
            new_target_list = []
            for target in self.target_list:
                if ".." in target:
                    new_target_list.append(os.path.normpath(os.path.join(old_dir, target)))
                elif os.path.exists(target):
                    new_target_list.append(target)
            self.target_list = new_target_list

    def __print_top_line(self):
        if self.wdir is None:
            return

        term_print(Sentence().add(symbols.opening).add(self.wdir.resume()), end="")
        term_print(" [", end="")
        first = True
        for unit in self.wdir.get_unit_list():
            if first:
                first = False
            else:
                term_print(" ", end="")
            solver = self.wdir.get_solver()
            if solver is None:
                raise Warning("Solver vazio")
            unit.result = Execution.run_unit(solver, unit)
            term_print(Sentence() + ExecutionResult.get_symbol(unit.result), end="")
        term_print("]")

    def __print_diff(self):
        if self.wdir is None or not self.wdir.has_solver():
            return
        
        if self.param.diff_mode == DiffMode.QUIET:
            return
        
        if self.wdir.get_solver().compile_error:
            term_print(self.wdir.get_solver().error_msg)
            return
        
        results = [unit.result for unit in self.wdir.get_unit_list()]
        if ExecutionResult.EXECUTION_ERROR not in results and ExecutionResult.WRONG_OUTPUT not in results:
            return
        
        if not self.param.compact:
            for elem in self.wdir.unit_list_resume():
                term_print(elem)
        
        if self.param.diff_mode == DiffMode.FIRST:
            # printing only the first wrong case
            wrong = [unit for unit in self.wdir.get_unit_list() if unit.result != ExecutionResult.SUCCESS][0]
            if self.param.is_up_down:
                for line in Diff.mount_up_down_diff(wrong):
                    term_print(line)
            else:
                for line in Diff.mount_side_by_side_diff(wrong):
                    term_print(line)
            return

        if self.param.diff_mode == DiffMode.ALL:
            for unit in self.wdir.get_unit_list():
                if unit.result != ExecutionResult.SUCCESS:
                    if self.param.is_up_down:
                        for line in Diff.mount_up_down_diff(unit):
                            term_print(line)
                    else:
                        for line in Diff.mount_side_by_side_diff(unit):
                            term_print(line)

    def build_wdir(self):
        self.wdir_builded = True
        self.__remove_duplicates()
        self.__change_targets_to_filter_mode()
        try:
            self.wdir = Wdir().set_curses(self.__curses_mode).set_lang(self.__lang).set_target_list(self.target_list).set_cmd(self.exec_cmd).build().filter(self.param)
        except FileNotFoundError as e:
            if self.wdir.has_solver():
                self.wdir.get_solver().error_msg += str(e)
                self.wdir.get_solver().compile_error = True
        return self.wdir

    def __missing_target(self) -> bool:
        if self.wdir is None:
            return False
        if not self.wdir.has_solver() and not self.wdir.has_tests():
            term_print(Sentence().addf("", "fail: ") + "Nenhum arquivo de código ou de teste encontrado.")
            return True
        return False
    
    def __list_mode(self) -> bool:
        if self.wdir is None:
            return False

        # list mode
        if not self.wdir.has_solver() and self.wdir.has_tests():
            term_print(Report.centralize(" Nenhum arquivo de código encontrado. Listando casos de teste.", Token("╌")), flush=True)
            term_print(self.wdir.resume())
            for line in self.wdir.unit_list_resume():
                term_print(line)
            return True
        return False

    def __free_run(self) -> bool:
        if self.wdir is None:
            return False
        if self.wdir.has_solver() and (not self.wdir.has_tests()):
            Free.free_run(self.wdir.get_solver(), show_compilling=False, to_clear=False, wait_input=False)
            return True
        return False

    def __diff_mode(self):
        if self.wdir is None:
            return
        
        if self.__curses_mode:
            cdiff = CDiff(self.wdir, self.param, self.__success_mode)
            if self.__first_run:
                cdiff.set_first_run()
            if self.__task is not None:
                cdiff.set_task(self.__task)
            if self.__opener is not None:
                cdiff.set_opener(self.__opener)
            cdiff.set_autorun(self.__autorun)
            cdiff.run()
        else:
            term_print(Report.centralize(" Testando o código com os casos de teste ", "═"))
            self.__print_top_line()
            self.__print_diff()


class Build:

    def __init__(self, target_out: str, source_list: List[str], param: Param.Manip, to_force: bool):
        self.target_out = target_out
        self.source_list = source_list
        self.param = param
        self.to_force = to_force

    def execute(self):
        try:
            wdir = Wdir().set_sources(self.source_list).build()
            wdir.manipulate(self.param)
            Writer.save_target(self.target_out, wdir.get_unit_list(), self.to_force)
        except FileNotFoundError as e:
            print(str(e))
            return False
        return True



class Graph:

    colorlist: List[Tuple[str, str]] = [
            ("aquamarine3", "aquamarine4"),
            ("bisque3", "bisque4"),
            ("brown3", "brown4"),
            ("chartreuse3", "chartreuse4"),
            ("coral3", "coral4"),
            ("cyan3", "cyan4"),
            ("darkgoldenrod3", "darkgoldenrod4"),
            ("darkolivegreen3", "darkolivegreen4"),
            ("darkorchid3", "darkorchid4"),
            ("darkseagreen3", "darkseagreen4"),
            ("darkslategray3", "darkslategray4"),
            ("deeppink3", "deeppink4"),
            ("deepskyblue3", "deepskyblue4"),
            ("dodgerblue3", "dodgerblue4"),
            ("firebrick3", "firebrick4"),
            ("gold3", "gold4"),
            ("green3", "green4"),
            ("hotpink3", "hotpink4"),
            ("indianred3", "indianred4"),
            ("khaki3", "khaki4"),
            ("lightblue3", "lightblue4"),
            ("lightcoral", "lightcoral"),
            ("lightcyan3", "lightcyan4"),
            ("lightgoldenrod3", "lightgoldenrod4"),
            ("lightgreen", "lightgreen"),
            ("lightpink3", "lightpink4"),
            ("lightsalmon3", "lightsalmon4"),
            ("lightseagreen", "lightseagreen"),
            ("lightskyblue3", "lightskyblue4"),
            ("lightsteelblue3", "lightsteelblue4"),
            ("lightyellow3", "lightyellow4"),
            ("magenta3", "magenta4"),
            ("maroon3", "maroon4"),
            ("mediumorchid3", "mediumorchid4"),
            ("mediumpurple3", "mediumpurple4"),
            ("mediumspringgreen", "mediumspringgreen"),
            ("mediumturquoise", "mediumturquoise"),
            ("mediumvioletred", "mediumvioletred"),
            ("mistyrose3", "mistyrose4"),
            ("navajowhite3", "navajowhite4"),
            ("olivedrab3", "olivedrab4"),
            ("orange3", "orange4"),
            ("orangered3", "orangered4"),
            ("orchid3", "orchid4"),
            ("palegreen3", "palegreen4"),
            ("paleturquoise3", "paleturquoise4"),
            ("palevioletred3", "palevioletred4")
            ]

    def __init__(self, game: Game):
        self.game = game
        self.reachable: Optional[List[str]] = None
        self.counts: Optional[Dict[str, str]] = None
        self.graph_ext = ".png"
        self.output = "graph"
        self.opt = False

    def set_opt(self, opt: bool):
        self.opt = opt
        return self

    def set_reachable(self, reachable: List[str]):
        self.reachable = reachable
        return self

    def set_counts(self, counts: Dict[str, str]):
        self.counts = counts
        return self

    def set_graph_ext(self, graph_ext: str):
        self.graph_ext = graph_ext
        return self
    
    def set_output(self, output: str):
        self.output = output
        return self

    def info(self, qx: Quest):
        text = f'{qx.title.strip()}'
        if self.reachable is None or self.counts is None:
            return f'"{text}"'
        return f'"{text}\\n{self.counts[qx.key]}"'

    def is_reachable_or_next(self, q: Quest):
        if self.reachable is None:
            return True
        if q.key in self.reachable:
            return True
        for r in q.requires_ptr:
            if r.key in self.reachable:
                return True
        return False

    def generate(self):
        saida = ["digraph diag {", '  node [penwidth=1, style="rounded,filled", shape=box]']

        targets = [q for q in self.game.quests.values() if self.is_reachable_or_next(q)]
        for q in targets:
            token = "->"
            if len(q.requires_ptr) > 0:
                for r in q.requires_ptr:
                    extra = ""
                    if self.reachable is not None:
                        if q.key not in self.reachable and not r.is_complete():
                            extra = "[style=dotted]"
                    saida.append(f"  {self.info(r)} {token} {self.info(q)} {extra}")
            else:
                v = '  "Início"'
                saida.append(f"{v} {token} {self.info(q)}")

        for i, c in enumerate(self.game.clusters.values()):
            cluster_targets = [q for q in c.quests if self.is_reachable_or_next(q)]
            for q in cluster_targets:
                if self.opt:
                    if q.opt:
                        fillcolor = "pink"
                    else:
                        fillcolor = "lime"
                else:
                    if c.color is not None:
                        fillcolor = c.color
                    else:
                        fillcolor = self.colorlist[i][0]

                    if q.opt:
                        fillcolor = f'"{fillcolor};0.9:orange"'
                    else:
                        fillcolor = f'"{fillcolor};0.9:lime"'
                shape = "ellipse"
                color = "black"
                width = 1
                if self.reachable is not None:
                    if q.key not in self.reachable:
                        color = "white"
                    else:
                        width = 3
                        color = q.get_grade_color()
                        if color == "g":
                            color = "green"
                        elif color == "r":
                            color = "red"
                        elif color == "y":
                            color = "yellow"
                        elif color == "m":
                            color = "magenta"
                saida.append(f"  {self.info(q)} [shape={shape} color={color} penwidth={width} fillcolor={fillcolor} ]")

        saida.append("}")
        # saida.append("@enduml")
        saida.append("")

        dot_file = self.output + ".dot"
        out_file = self.output + self.graph_ext
        open(dot_file, "w").write("\n".join(saida))

        if self.graph_ext == ".png":
            subprocess.run(["dot", "-Tpng", dot_file, "-o", out_file])
        elif self.graph_ext == ".svg":
            subprocess.run(["dot", "-Tsvg", dot_file, "-o", out_file])
        else:
            print("Formato de imagem não suportado")


class XP:
    token_level_one = "level_one"
    token_level_mult = "level_mult"
    level_one: int = 100
    level_mult: float = 1.5
    
    def __init__(self, game: Game):
        self.game = game
        self.obtained = 0
        self.avaliable = 0
        self.update()
        self.level = self.get_level()
    
    def update(self):
        self.obtained, self.avaliable = self.game.get_xp_resume()

    def get_level(self) -> int:
        return self.calc_level(self.obtained)

    def get_xp_level_current(self) -> int:
        xp_prev = self.calc_xp(self.level)
        atual = self.obtained - xp_prev
        return atual

    def get_xp_level_needed(self) -> int:
        xp_next = self.calc_xp(self.level + 1)
        xp_prev = self.calc_xp(self.level)
        return xp_next - xp_prev

    def get_xp_total_obtained(self) -> int:
        return self.obtained

    def get_xp_total_available(self) -> int:
        return self.avaliable

    def calc_level(self, xp) -> int:
        level = 1
        while self.calc_xp(level) <= xp:
            level += 1
        return level - 1
    
    def calc_xp(self, level: int) -> int:
        total = 0
        for i in range(level - 1):
            total += self.game.level_one * (int(self.game.level_mult) ** i)
        return int(total)








class Actions:
    ler_online = "Github"
    sair = "Sair"
    ajuda = "Ajuda"
    baixar = "Baixar"
    ativar = "Ativar"
    navegar = "←↓→"
    editar = "Editar"
    marcar = "Marcar"
    desmarcar = "Desmarcar"
    colapsar = "Colapsar"
    pesquisar = "Buscar"

class Key:
    left = "a"
    # left2 = "h"
    right = "d"
    # right2 = "l"
    down = "s"
    # down2 = "j"
    up = "w"
    # up2 = "k"

    down_task = "b"
    # select_task = "t"
    select_task = "\n"
    ajuda = "h"
    expand = ">"
    expand2 = "."
    collapse = "<"
    collapse2 = ","
    inc_grade = "+"
    inc_grade2 = "="
    dec_grade = "-"
    dec_grade2 = "_"
    set_root_dir = "D"
    set_lang = "L"
    github_open = "g"
    quit = "q"
    # toggle_space = " "
    # toggle_enter = "\n"
    edit= "e"
    cores = "C"
    bordas = "B"
    pesquisar = "/"

class Play:
    def __init__(
        self,
        app: AppSettings,
        game: Game,
        rep_data: RepData,
        rep_alias: str
    ):
        self.app = app
        self.rep_alias = rep_alias
        self.rep = rep_data
        self.settings = Settings()
        self.exit = False

        if self.rep.get_lang() == "":
            self.rep.set_lang(self.app.get_lang_def())
        self.flagsman = FlagsMan(self.rep.get_flags())
        
        self.game: Game = game
        self.fman = FloatingManager()
        self.tree = TaskTree(app, game, rep_data, rep_alias)

        if len(self.rep.get_tasks()) == 0:
            self.show_help()

        self.first_loop = True
        self.graph_ext = ""

        self.help_basic: List[Sentence] = [
            Sentence() + RToken("Y", f"{Actions.pesquisar}[{Key.pesquisar}]"),
            Sentence() + RToken("Y", f"{Actions.marcar} {Key.inc_grade}{Key.dec_grade}"),
        ]

        self.help_fixed: List[Sentence] = [
            Sentence() + RToken("C", f"  {Actions.sair}[{Key.quit}]"),
            Sentence() + RToken("C", f"{Actions.editar}[{Key.edit}]"),
            Sentence() + RToken("C", f"{Actions.ativar}[↲]"),
        ]
        self.help_others_before: List[Sentence] = [
            Sentence() + RToken("Y", f" {Actions.ajuda}[{Key.ajuda}]"),
            Sentence() + RToken("Y", f"{Actions.ler_online}[{Key.github_open}]"),
        ]
        self.help_others_after: List[Sentence] = [
            Sentence() + RToken("Y", f"{Actions.baixar}[{Key.down_task}]"),
            Sentence() + RToken("Y", f"{Actions.navegar}[wasd]")
        ]

        self.wrap_size = Sentence(" ").join(self.build_bottom_array()).len()

        self.opener = Opener(tree=self.tree, fman=self.fman, geral=app, rep_data=rep_data, rep_alias=rep_alias)

        self.search_mode: bool = False
        self.backup_expanded: List[str] = []
        self.backup_index_selected = 0
        self.backup_admin_mode = False

    def save_to_json(self):
        self.tree.save_on_rep()
        self.rep.set_flags(self.flagsman.get_data())
        self.settings.save_settings()
        self.rep.save_data_to_json()

    def set_rootdir(self, only_if_empty=True):
        if only_if_empty and self.app.get_rootdir() != "":
            return

        def chama(value):
            if value == "yes":
                self.app.set_rootdir(os.path.abspath(os.getcwd()))
                self.save_to_json()
                self.fman.add_input(
                    Floating()
                    .put_text("")
                    .put_text("Diretório raiz definido como ")
                    .put_text("")
                    .put_text("  " + os.getcwd())
                    .put_text("")
                    .put_text("Você pode também pode alterar")
                    .put_text("o diretório raiz navegando para o")
                    .put_text("diretório desejado e executando o comando")
                    .put_text("")
                    .put_text("  tko config --root .")
                    .put_text("")
                    .warning()
                )
            else:
                self.fman.add_input(
                    Floating()
                    .put_text("")
                    .put_text("Navegue para o diretório desejado e tente novamente.")
                    .put_text("")
                    .put_text("Você pode também pode alterar")
                    .put_text("o diretório raiz navegando para o")
                    .put_text("diretório desejado e executando o comando")
                    .put_text("")
                    .put_text("tko config --root .")
                    .put_text("")
                    .warning()
                )

        self.fman.add_input(
            Floating()
            .put_text("")
            .put_text("Você deseja utilizar o diretório")
            .put_text("atual como diretório raiz do tko?")
            .put_text("")
            .put_text(os.getcwd())
            .put_text("")
            .put_text("como raiz para o repositório de " + self.rep_alias + "?")
            .put_text("")
            .put_text("Selecione e tecle Enter")
            .put_text("")
            .set_options(["yes", "no"])
            .answer(chama)
        )

    def set_language(self, only_if_empty=True):
        if only_if_empty and self.rep.get_lang() != "":
            return

        def back(value):
            self.rep.set_lang(value)
            self.save_to_json()
            self.fman.add_input(
                Floating()
                .put_text("")
                .put_text("Linguagem alterada para " + value)
                .put_text("")
                .warning()
            )

        self.fman.add_input(
            Floating()
            .put_text("")
            .put_text("Escolha a extensão default para os rascunhos")
            .put_text("")
            .put_text("Selecione e tecle Enter.")
            .put_text("")
            .set_options(languages_avaliable)
            .answer(back)
        )

    def check_root_and_lang(self):
        if self.app.get_rootdir() == "":
            # self.set_rootdir()
            self.fman.add_input(
                Floating()
                .put_text("")
                .put_text("O diretório de download padrão")
                .put_text("do tko ainda não foi definido.")
                .put_text("")
                .put_sentence(Sentence() + "Utilize o comando " + Token("Shift + " + Key.set_root_dir, "g"))
                .put_text("para configurá-lo.")
                .put_text("")
            )

        if self.rep.get_lang() == "":
            self.fman.add_input(
                Floating()
                .put_text("")
                .put_text("A linguagem de download padrão")
                .put_text("para os rascunhos ainda não foi definda.")
                .put_text("")
                .put_sentence(Sentence() + "Utilize o comando " + Token("Shift + " + Key.set_lang, "g"))
                .put_text("para configurá-la.")
                .put_text("")
            )
            return


    def open_link(self):
        obj = self.tree.get_selected()
        if isinstance(obj, Task):
            task: Task = obj
            if task.link.startswith("http"):
                try:
                    webbrowser.open_new_tab(task.link)
                except Exception as _:
                    pass
            self.fman.add_input(
                Floating("v>")
                .set_header(" Abrindo link ")
                .put_text("\n" + task.link + "\n")
                .warning()
            )
        elif isinstance(obj, Quest):
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEssa é uma missão.")
                .put_text("\nVocê só pode abrir o link")
                .put_text("de tarefas.\n")
                .error()
            )
        else:
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEsse é um grupo.")
                .put_text("\nVocê só pode abrir o link")
                .put_text("de tarefas.\n")
                .error()
            )

    def generate_graph(self):
        if not self.first_loop:
            return
        if self.graph_ext == "":
            return
        reachable: List[str] = self.game.available_quests
        counts = {}
        for q in self.game.quests.values():
            done = len([t for t in q.get_tasks() if t.is_complete()])
            init = len([t for t in q.get_tasks() if t.in_progress()])
            todo = len([t for t in q.get_tasks() if t.not_started()])
            counts[q.key] = f"{done} / {done + init + todo}\n{q.get_percent()}%"

        # mark_opt = Flags.dots.is_true()
        Graph(self.game).set_opt(False).set_reachable(reachable).set_counts(
            counts
        ).set_graph_ext(self.graph_ext).generate()
        lines, _ = Fmt.get_size()
        if self.first_loop:
            text = Sentence().add(f"Grafo gerado em graph{self.graph_ext}")
            Fmt.write(lines - 1, 0, text)

    def down_task(self):
        rootdir = self.app.get_rootdir()
        if rootdir == "":
            self.check_root_and_lang()
            return
        lang = self.rep.get_lang()
        if lang == "":
            self.check_root_and_lang()
            return

        obj = self.tree.items[self.tree.index_selected].obj
        if isinstance(obj, Task) and obj.key in obj.title:
            task: Task = obj
            down_frame = (
                Floating("v>").warning().set_ljust_text().set_header(" Baixando tarefa ")
            )
            down_frame.put_text(f"\ntko down {self.rep_alias} {task.key} -l {lang}\n")
            self.fman.add_input(down_frame)

            def fnprint(text):
                down_frame.put_text(text)
                down_frame.draw()
                Fmt.refresh()
            Down.download_problem(self.rep_alias, task.key, lang, fnprint, self.game)
        else:
            if isinstance(obj, Quest):
                self.fman.add_input(
                    Floating("v>")
                    .put_text("\nEssa é uma missão.")
                    .put_text("\nVocê só pode baixar tarefas.\n")
                    .error()
                )
            elif isinstance(obj, Cluster):
                self.fman.add_input(
                    Floating("v>")
                    .put_text("\nEsse é um grupo.")
                    .put_text("\nVocê só pode baixar tarefas.\n")
                    .error()
                )
            else:
                self.fman.add_input(
                    Floating("v>").put_text("\nEssa não é uma tarefa de código.\n").error()
                )
    
    def select_task(self):
        rootdir = self.app.get_rootdir()
        
        obj = self.tree.items[self.tree.index_selected].obj

        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            self.tree.toggle(obj)
            return

        rep_dir = os.path.join(rootdir, self.rep_alias)
        task: Task = obj
        if not task.is_downloadable():
            # self.fman.add_input( Floating().put_text("\nEssa não é uma tarefa de código.\n").error() )
            self.open_link()
            return
        if not task.is_downloaded_for_lang(rep_dir, self.rep.get_lang()):
            self.down_task()
            # self.fman.add_input(
            #     Floating().put_text("\nVocê precisa baixar a tarefa primeiro\n").error()
            # )
            return
        return self.run_selected_task(task, rep_dir)
        
    def run_selected_task(self, task: Task, rep_dir: str):
        path = os.path.join(rep_dir, task.key)
        run = Run([path], None, Param.Basic())
        run.set_lang(self.rep.get_lang())
        run.set_opener(self.opener)
        run.set_autorun(False)
        if Flags.images.is_true():
            run.set_curses(True, Success.RANDOM)
        else:
            run.set_curses(True, Success.FIXED)
        run.set_task(task)

        run.build_wdir()
        if not run.wdir.has_solver():
            msg = Floating("v>").error()
            msg.put_text("\nNenhum arquivo de código na linguagem {} encontrado.".format(self.rep.get_lang()))
            msg.put_text("Arquivos encontrados na pasta:\n")
            folder = run.wdir.get_autoload_folder()
            file_list = [file for file in os.listdir(folder) if os.path.isfile(os.path.join(folder, file))]
            for file in file_list:
                msg.put_text(file)
            msg.put_text("")
            self.fman.add_input(msg)
            return
        return run.execute

    def build_list_sentence(self, items: List[Sentence]) -> List[Sentence]:
        out: List[Sentence] = []
        for x in items:
            color_ini = x.data[0].fmt if self.app.is_colored() else "W"
            color_end = x.data[-1].fmt if self.app.is_colored() else "W"
            left = Style.roundL()
            right = Style.roundR()
            middle = x.clone()
            if x.data[0].text == "!":
                left = Style.sharpL()
                right = Style.sharpR()
                middle.data = x.data[1:]
            out.append(Sentence().addf(color_ini.lower(), left).add(middle).addf(color_end.lower(), right))
        return out

    def build_bar_links(self) -> str:
        if not self.tree.items:
            return ""
        obj = self.tree.items[self.tree.index_selected].obj
        if isinstance(obj, Task):
            link = obj.link
            if link:
                return link
        return ""

    def get_task_path(self) -> str:
        obj = self.tree.get_selected()
        if not isinstance(obj, Task):
            return ""
        
        path = os.path.join(self.app.get_rootdir(), self.rep_alias, obj.key, "Readme.md")
        if os.path.isfile(path):
            return path
        return ""
    
    def show_main_bar(self, frame: Frame):
        dy, dx = frame.get_inner()
        top = Sentence()
        if self.two_column_mode() and Flags.others.is_true(): 
            top.add(Style.get_flag_sentence(Flags.config)).add(" ")

        alias_color = "R"
        top.addf(alias_color.lower(), Style.sharpL()).addf(alias_color, self.rep_alias.upper()).addf(alias_color.lower(), Style.sharpR())
        if Flags.others.is_true():
            color = "W" if Flags.admin.is_true() else "K"
            top.add(Style.border_sharp(color, "ADMIN"))
        top.addf("g", Style.sharpL()).addf("G", self.rep.get_lang().upper()).addf("g", Style.sharpR())

        if self.two_column_mode() and Flags.others.is_true(): 
            top.add(" ").add(Style.get_flag_sentence(Flags.skills))

        frame.set_header(top, "^")
        
        if self.two_column_mode():
            elems = self.build_bottom_array()
            line_up = Sentence(" ").join(elems[0 : 2] + elems[-2:])
            frame.set_footer(line_up, "")
        frame.draw()

        for y, sentence in enumerate(self.tree.get_senteces(dy)):
            if sentence.len() > dx:
                sentence.trim_end(dx - 3)
                sentence.addf("r", "...")
            frame.write(y, 0, sentence)

    def show_inventary_bar(self, frame_xp):
        dy, dx = frame_xp.get_inner()
        xp = XP(self.game)
        total_perc = int(
            100 * (xp.get_xp_total_obtained() / xp.get_xp_total_available())
        )
        if Flags.percent.is_true():
            text = f" XPTotal:{total_perc}%"
        else:
            text = f" XPTotal:{xp.get_xp_total_obtained()}"

        done = Style.main_done() + "/"
        todo = Style.main_todo() + "/"
        total_bar = Style.build_bar(text, total_perc / 100, dx - 2, done, todo)
        frame_xp.set_header(Sentence().addf("/", "Skills"), "^", "{", "}")
        frame_xp.set_footer(Sentence().add(" ").add(self.app.get_rootdir()).add(" "), "^")
        frame_xp.draw()



        total, obt = self.game.get_skills_resume([self.game.quests[key] for key in self.game.available_quests])
        elements: List[Sentence] = []
        for skill, value in total.items():
            if Flags.percent.is_true():
                text = f"{skill}:{int(100 * obt[skill] / value)}%"
            else:
                text = f"{skill}:{obt[skill]}/{value}"
            perc = obt[skill] / value
            done = Style.skill_done() + "/"
            todo = Style.skill_todo() + "/"
            skill_bar = Style.build_bar(text, perc, dx - 2, done, todo)
            elements.append(skill_bar)
            
        elements.append(total_bar)

        line_breaks = dy - len(elements)
        for skill_bar in elements:
            frame_xp.print(1, skill_bar)
            if line_breaks > 0:
                line_breaks -= 1
                frame_xp.print(1, Sentence())

    def show_config_bar(self, frame: Frame):
        frame.set_header(Sentence().addf("/", "Config"), "^", "{", "}")
        frame.draw()

        elements: List[Sentence] = []
        pad = 11
        for flag in self.flagsman.left:
            elements.append(Style.get_flag_sentence(flag, pad))


        colored = Flag().name("Colorido").char("C").values(["1" if self.app.is_colored() else "0"]).text("Ativa ou desativa as cores").bool()
        elements.append(Style.get_flag_sentence(colored, pad))
        bordas = Flag().name("Bordas").char("B").values(["1" if self.app.is_nerdfonts() else "0"]).text("Ativa ou desativa as bordas").bool()
        elements.append(Style.get_flag_sentence(bordas, pad))
        
        color = "W" if not self.app.is_colored() else "C"
        elements.append(Sentence().addf(color.lower(), Style.roundL()).addf(color, "DirDestino [D]").addf(color.lower(), Style.roundR()))
        elements.append(Sentence().addf(color.lower(), Style.roundL()).addf(color, "Linguagem  [L]").addf(color.lower(), Style.roundR()))

        # dy, dx = frame.get_inner()
        # line_breaks = dy - len(elements) + 1
        # for i, elem in enumerate(elements):
        #     frame.print(0, elem)
        #     if line_breaks > len(elements) - i - 1:
        #         # line_breaks -= 1
        #         frame.print(0, Sentence())
        dy, dx = frame.get_inner()
        line_breaks = dy - len(elements)
        for i, elem in enumerate(elements):
            frame.print(0, elem)
            if line_breaks > 0:
                line_breaks -= 1
                frame.print(0, Sentence())

    def two_column_mode(self):
        _, cols = Fmt.get_size()
        return cols < self.wrap_size + 2 and Flags.others.is_true()

    def build_bottom_array(self):
        array: List[Sentence] = []
        array += self.help_others_before
        array += self.help_fixed
        color = "G" if Flags.others.is_true() else "Y"
        array.append(Sentence() + RToken(color, "!Outros[o]"))
        array += self.help_others_after

        return self.build_list_sentence(array)

    def show_bottom_bar(self):
        lines, cols = Fmt.get_size()
        elems = self.build_bottom_array()
        if self.two_column_mode():
            line_down = Sentence(" ").join(elems[2:-2])
            Fmt.write(lines - 1, 0, line_down.center(cols))
        else:
            if Flags.others.is_true():
                line_all = Sentence(" ").join(elems)
                Fmt.write(lines - 1, 0, line_all.center(cols))
            else:
                line_main = Sentence(" ").join(elems[2: -2]) # alignment adjust
                Fmt.write(lines - 1, 0, line_main.center(cols))   

    def make_xp_button(self, size):
        if self.search_mode:
            text = " Busca: " + self.tree.search_text + "┊"
            percent = 0.0
            done = "W"
            todo = "W"
            text = text.ljust(size)
        else:
            text, percent = self.build_xp_bar()
            done = Style.main_done()
            todo = Style.main_todo()
            text = text.center(size)
        xpbar = Style.build_bar(text, percent, len(text), done, todo)
        return xpbar

    def show_top_bar(self, frame: Frame):
        help = self.build_list_sentence(self.help_basic)
        pesquisar = help[0]
        marcar = help[1]
        config = Style.get_flag_sentence(Flags.config)
        skills = Style.get_flag_sentence(Flags.skills)
        others = Flags.others.is_true()

        pre: List[Sentence] = []
        pre.append(marcar)
        if others and not self.two_column_mode():
            pre.append(config)

        pos: List[Sentence] = []
        if others and not self.two_column_mode():
            pos.append(skills)
        pos.append(pesquisar)

        limit = self.wrap_size
        if frame.get_dx() < self.wrap_size:
            limit = frame.get_dx()
        size = limit - Sentence(" ").join(pre + pos).len() - 2
        main_label = self.make_xp_button(size)
        info = Sentence(" ").join(pre + [main_label] + pos)
        frame.write(0, 0, info.center(frame.get_dx()))


        # frame.set_border_none()
        # frame.set_border_rounded()
        # frame.draw()

    def show_help_config(self):
        _help: Floating = Floating("v>").warning().set_ljust_text().set_header(" Configurações ")
        self.fman.add_input(_help)
        _help.put_sentence(Sentence() + f"      Mínimo " + RToken("r", f"[{Flags.minimum.get_char()}]") + " - Mostrar os requisitos mínimos para completar a missão")
        _help.put_sentence(Sentence() + f"  Recompensa " + RToken("r", f"[{Flags.reward.get_char()}]") + " - Mostrar quanto de experiência cada atividade fornece")
        _help.put_sentence(Sentence() + f"  Percentual " + RToken("r", f"[{Flags.percent.get_char()}]") + " - Mostrar os valores em percentual")
        _help.put_sentence(Sentence() + f"  ModoAdmin " + RToken("r", f"Shift + [A]") + " - Liberar acesso a todas as missões" )
        _help.put_sentence(Sentence() + f"  PastaRaiz " + RToken("r", f"Shift + [{Key.set_root_dir}]") + " - Mudar a pasta padrão de download do tko" )
        _help.put_sentence(Sentence() + f"  Linguagem " + RToken("r", f"Shift + [{Key.set_lang}]") + " - Mudar a linguagem de download dos rascunhos" )


    def show_help(self):
        # def empty(value):
        #     pass
        _help: Floating = Floating("v>").set_ljust_text()
        self.fman.add_input(_help)

        _help.set_header_sentence(Sentence().add(" Ajuda "))
        # _help.put_text(" Movimentação ".center(dx, symbols.hbar.text))
        _help.put_sentence(Sentence("    Ajuda ").addf("r", Key.ajuda).add("  Abre essa tela de ajuda")
        )

        _help.put_sentence(Sentence("  ").addf("r", "Shift + B")
                           .add("  Habilita ").addf("r", "").addf("R", "ícones").addf("r", "").add(" se seu ambiente suportar"))
        _help.put_sentence(Sentence() + "" + RToken("g", "setas") + ", " + RToken("g", "wasd")  + "  Para navegar entre os elementos")
        _help.put_sentence(Sentence() + f"{Actions.ler_online} " + RToken("r", f"{Key.github_open}") + "  Abre tarefa em uma aba do browser")
        _help.put_sentence(Sentence() + f"   {Actions.baixar} " + RToken("r", f"{Key.down_task}") + "  Baixa tarefa de código para seu dispositivo")
        _help.put_sentence(Sentence() + f"   {Actions.editar} " + RToken("r", f"{Key.edit}") + "  Abre os arquivos no editor de código")
        _help.put_sentence(Sentence() + f"   {Actions.ativar} " + RToken("r", "↲") + "  Interage com o elemento")
        _help.put_sentence(Sentence() + f"   {Actions.marcar} " + RToken("r", f"{Key.inc_grade}") + RToken("r", f"{Key.dec_grade}") + " Muda a pontuação da tarefa")
        _help.put_sentence(Sentence())
        _help.put_sentence(Sentence() + "Você pode mudar o editor padrão com o comando")
        _help.put_sentence(Sentence() + RToken("g", "             tko config --editor <comando>"))

    @staticmethod
    def disable_on_resize():
        _, cols = Fmt.get_size()
        if cols < 50 and Flags.skills.is_true() and Flags.config.is_true():
            Flags.skills.toggle()
        elif cols < 30 and Flags.skills.is_true():
            Flags.skills.toggle()
        elif cols < 35 and Flags.config.is_true():
            Flags.config.toggle()


    def build_xp_bar(self) -> Tuple[str, float]:
        xp = XP(self.game)
        if xp.get_xp_total_obtained() == xp.get_xp_total_available():
            text = "Você atingiu o máximo de xp!"
            percent = 100.0
        else:
            # lang = self.rep.get_lang().upper()
            level = xp.get_level()
            percent = float(xp.get_xp_level_current()) / float(xp.get_xp_level_needed())
            if Flags.percent.is_true():
                xpobt = int(100 * xp.get_xp_level_current() / xp.get_xp_level_needed())
                text = "Level:{} XP:{}%".format(level, xpobt)
            else:
                xpobt1 = xp.get_xp_level_current()
                xpobt2 = xp.get_xp_level_needed()
                text = "Level:{} XP:{}/{}".format(level, xpobt1, xpobt2)

        return text, percent

    def show_opening(self):
        if Fmt.get_size()[1] < 100:
            return
        if not Flags.images.is_true():
            return
        _, cols = Fmt.get_size()
        
        now = datetime.datetime.now()
        parrot = random_get(opening, str(now.hour))
        parrot_lines = parrot.split("\n")
        max_len = max([len(line) for line in parrot_lines])
        yinit = 1
        for y, line in enumerate(parrot_lines):
            Fmt.write(yinit + y, cols - max_len - 2, Sentence().addf("g", line))

    def show_items(self):
        border_color = "r" if Flags.admin.is_true() else ""
        Fmt.clear()
        self.tree.reload_sentences()
        lines, cols = Fmt.get_size()
        main_sx = cols  # tamanho em x livre
        main_sy = lines  # size em y avaliable

        top_y = -1
        top_dy = 1  #quantas linhas o topo usa
        bottom_dy = 1 # quantas linhas o fundo usa
        mid_y = top_dy # onde o meio começa
        mid_sy = main_sy - top_dy - bottom_dy # tamanho do meio

        skills_sx = 0
        if Flags.skills.is_true():
            skills_sx = max(20, main_sx // 4)
        else:
            self.show_opening()

        flags_sx = 0
        if Flags.config.is_true():
            flags_sx = 18            

        task_sx = main_sx - flags_sx - skills_sx

        frame_top = Frame(top_y, 0).set_size(top_dy + 2, cols)
        self.show_top_bar(frame_top)

        # frame_bottom = Frame(lines - bottom_dy - 1, -1).set_size(bottom_dy + 2, cols + 2)
        self.show_bottom_bar()
        if task_sx > 5: 
            frame_main = Frame(mid_y, flags_sx).set_size(mid_sy, task_sx).set_border_color(border_color)
            self.show_main_bar(frame_main)

        if Flags.config.is_true():
            frame_flags = Frame(mid_y, 0).set_size(mid_sy, flags_sx).set_border_color(border_color)
            self.show_config_bar(frame_flags)

        if Flags.skills.is_true():
            frame_skills = Frame(mid_y, cols - skills_sx).set_size(mid_sy, skills_sx).set_border_color(border_color)
            self.show_inventary_bar(frame_skills)


    class FlagFunctor:
        def __init__(self, fman: FloatingManager, flag: Flag):
            self.fman = fman
            self.flag = flag

        def __call__(self):
            self.flag.toggle()
            if (self.flag.get_location() == "left" or self.flag.get_location() == "geral") and self.flag.is_bool():
                f = Floating("v>").warning()
                f.put_text("")
                f.put_text(self.flag.get_description())
                if self.flag.is_true():
                    f.put_sentence(Sentence().addf("g", "ligado"))
                else:
                    f.put_sentence(Sentence().addf("r", "desligado"))
                f.put_text("")
                self.fman.add_input(f)

    class GradeFunctor:
        def __init__(self, grade: int, fn):
            self.grade = grade
            self.fn = fn

        def __call__(self):
            self.fn(self.grade)

    def toggle_config(self):
        if Flags.config.is_true():
            Flags.config.toggle()
        else:
            Flags.config.toggle()
            # self.show_help_config()

    def select_quit_msg(self):
        if Flags.fortune.is_true():
            return random.choice(quit_msgs)
        return "Até a próxima!"

    def send_quit_msg(self):
        def set_exit():
            self.exit = True

        self.fman.add_input(
            Floating().put_text("\n" + self.select_quit_msg() + "\n").set_exit_fn(set_exit).warning()
        ),

    def make_callback(self) -> Dict[int, Any]:
        calls: Dict[int, Callable[[],None]] = {}

        def add_int(_key: int, fn):
            if _key in calls.keys():
                raise ValueError(f"Chave duplicada {chr(_key)}")
            calls[_key] = fn

        def add_str(str_key: str, fn):
            if str_key != "":
                add_int(ord(str_key), fn)

        add_int(curses.KEY_RESIZE, self.disable_on_resize)
        add_str(Key.quit, self.send_quit_msg)
        add_int(27, self.send_quit_msg)
        add_int(curses.KEY_BACKSPACE, self.send_quit_msg)


        add_str(Key.up, self.tree.move_up)
        add_int(curses.KEY_UP, self.tree.move_up)

        add_str(Key.down, self.tree.move_down)
        add_int(curses.KEY_DOWN, self.tree.move_down)

        add_str(Key.left, self.tree.arrow_left)
        add_int(curses.KEY_LEFT, self.tree.arrow_left)

        add_str(Key.right, self.tree.arrow_right)
        add_int(curses.KEY_RIGHT, self.tree.arrow_right)

        add_str(Key.ajuda, self.show_help)
        add_str(Key.expand, self.tree.process_expand)
        add_str(Key.expand2, self.tree.process_expand)
        add_str(Key.collapse, self.tree.process_collapse)
        add_str(Key.collapse2, self.tree.process_collapse)
        add_str(Key.github_open, self.open_link)
        add_str(Key.set_lang, lambda: self.set_language(False))
        add_str(Key.set_root_dir, lambda: self.set_rootdir(False))
        add_str(Key.down_task, self.down_task)
        add_str(Key.select_task, self.select_task)
        add_str("t", lambda: self.fman.add_input(Floating().put_text("\n Use o Enter para testar uma questão\n").warning()))
        add_str(Key.inc_grade, self.tree.inc_grade)
        add_str(Key.inc_grade2, self.tree.inc_grade)
        add_str(Key.dec_grade, self.tree.dec_grade)
        add_str(Key.dec_grade2, self.tree.dec_grade)
        add_str(Key.edit, lambda: self.opener.open_code(open_dir=True))
        add_str(Key.cores, self.app.toggle_color)
        add_str(Key.bordas, self.app.toggle_nerdfonts)

        for value in range(1, 10):
            add_str(str(value), self.GradeFunctor(int(value), self.tree.set_grade))
        add_str("'", self.GradeFunctor(0, self.tree.set_grade))
        add_str("0", self.GradeFunctor(10, self.tree.set_grade))

        for flag in self.flagsman.left:
            add_str(flag.get_char(), self.FlagFunctor(self.fman, flag))
        for flag in self.flagsman.others:
            add_str(flag.get_char(), self.FlagFunctor(self.fman, flag))

        add_str(Flags.config.get_char(), self.toggle_config)
        add_str(Flags.skills.get_char(), self.FlagFunctor(self.fman, Flags.skills))
        add_str("/", self.toggle_search)

        return calls

    def toggle_search(self):
        self.search_mode = not self.search_mode
        if self.search_mode:
            self.backup_expanded = [v for v in self.tree.expanded]
            self.backup_index_selected = self.tree.index_selected
            self.backup_admin_mode = Flags.admin.is_true()
            self.tree.update_tree(admin_mode=True)
            self.tree.process_expand()
            self.tree.process_expand()
            self.fman.add_input(Floating(">v").warning().put_text("Digite o texto\nVavegue até o elemnto desejado\ne aperte Enter"))
    
    def finish_search(self):
        self.search_mode = False
        unit = self.tree.get_selected()
        self.tree.index_selected = 0
        self.tree.search_text = ""
        if self.backup_admin_mode == False:
            self.tree.update_tree(admin_mode=False)
        self.tree.reload_sentences()
    
        found = False
        for i, item in enumerate(self.tree.items):
            if item.obj == unit:
                self.tree.index_selected = i
                found = True
                break

        if not found:
            self.fman.add_input(Floating(">v").warning().put_text("Elemento não acessível no modo normal.\nEntrando no modo Admin\npara habilitar acesso"))
            Flags.admin.toggle()
            self.tree.update_tree(True)
            self.tree.reload_sentences()
        
        self.tree.process_collapse()
        self.tree.process_collapse()

        if isinstance(unit, Task):
            for cluster_key in self.game.available_clusters:
                cluster = self.game.clusters[cluster_key]
                for quest in cluster.quests:
                    for task in quest.get_tasks():
                        if task == unit:
                            self.tree.expanded = [cluster.key, quest.key]
        elif isinstance(unit, Quest):
            for cluster_key in self.game.available_clusters:
                cluster = self.game.clusters[cluster_key]
                for quest in cluster.quests:
                    if quest == unit:
                        self.tree.expanded = [cluster.key]
        self.tree.reload_sentences()
        for i, item in enumerate(self.tree.items):
            if item.obj == unit:
                self.tree.index_selected = i
                break


    def process_search(self, key):
        if key == 27:
            self.search_mode = False
            self.tree.search_text = ""
            self.tree.expanded = [v for v in self.backup_expanded]
            self.tree.index_selected = self.backup_index_selected
        elif key == ord("\n"):
            self.finish_search()
    
        elif key == curses.KEY_UP:
            self.tree.move_up()
        elif key == curses.KEY_DOWN:
            self.tree.move_down()
        elif key == 127 or key == 263 or key == 330:
            self.tree.search_text = self.tree.search_text[:-1]
        elif key >= 32 and key < 127:
            self.tree.search_text += chr(key).lower()
        

    def send_char_not_found(self, key):
        self.fman.add_input(
            Floating("v>")
                .error()
                .put_text("Tecla")
                .put_text(f"char {chr(key)}")
                .put_text(f"code {key}")
                .put_text("não reconhecida")
                .put_text("")
        )

    # def send_dont_use_enter(self):
    #     self.fman.add_input(
    #         Floating("v>")
    #             .put_text("\n")
    #             .put_text("Utilize esquerda e direita\npara marcar as questões")
    #             .put_text("e compactar e expandir tópicos \n")
    #             .put_text("")
    #     )

    def main(self, scr):
        if hasattr(curses, "set_escdelay"):
            curses.set_escdelay(25)
        else:
            os.environ.setdefault('ESCDELAY', '25')
        # verify if curses has method set_escdelay
        curses.curs_set(0)  # Esconde o cursor
        Fmt.init_colors()  # Inicializa as cores
        Fmt.set_scr(scr)  # Define o scr como global

        while not self.exit:
            self.tree.update_tree(admin_mode=Flags.admin.is_true() or self.search_mode)
            self.fman.draw_warnings()
            self.generate_graph()
            calls = self.make_callback()
            self.show_items()

            if self.fman.has_floating():
                value: int = self.fman.get_input()
            else:
                value = scr.getch()
                if value == 195:
                    value = scr.getch()
                    if value == 167: #ç
                        value = ord("c")

            if self.search_mode:
                self.process_search(value)
            elif value in calls.keys():
                callback = calls[value]()
                if callback is not None:
                    return callback
            elif value != -1 and value != 27:
                self.send_char_not_found(value)

            self.tree.reload_sentences()
            self.save_to_json()
            if self.first_loop:
                self.first_loop = False

    def check_lang_in_text_mode(self):
        lang = self.rep.get_lang()
        if lang == "":
            options = languages_avaliable
            print("\nLinguagem padrão ainda não foi definida.\n")
            while True:
                print("Escolha entre as opções a seguir ", end="")
                print("[" + ", ".join(options) + "]", ":", end=" ")
                lang = input()
                if lang in options:
                    break
            self.rep.set_lang(lang)

    def play(self, graph_ext: str):
        self.graph_ext = graph_ext
        self.check_lang_in_text_mode()

        while True:
            output = curses.wrapper(self.main)
            if output is None:
                return
            else:
                output()











class MRep:
    @staticmethod
    def list(_args):
        settings = Settings()
        print(f"SettingsFile\n- {settings.settings_file}")
        print(str(settings))

    @staticmethod
    def add(args):
        settings = Settings()
        rep = RepSource()
        if args.url:
            rep.set_url(args.url)
        elif args.file:
            rep.set_file(args.file)
        settings.reps[args.alias] = rep
        settings.save_settings()

    @staticmethod
    def rm(args):
        sp = Settings()
        if args.alias in sp.reps:
            sp.reps.pop(args.alias)
            sp.save_settings()
        else:
            print("Repository not found.")

    @staticmethod
    def reset(_):
        sp = Settings().reset()
        print(sp.settings_file)
        print(sp.app.get_rootdir())
        sp.save_settings()

    @staticmethod
    def graph(args):
        settings = Settings()
        rep_source:RepSource = settings.get_rep_source(args.alias)
        file = rep_source.get_file(os.path.join(settings.app.get_rootdir(), args.alias))
        game = Game()
        game.parse_file(file)
        game.check_cycle()
        Graph(game).generate()


class Main:
    @staticmethod
    def prun(args):
        PatternLoader.pattern = args.pattern
        param = Param.Basic().set_index(args.index)
        if args.quiet:
            param.set_diff_mode(DiffMode.QUIET)
        elif args.all:
            param.set_diff_mode(DiffMode.ALL)
        else:
            param.set_diff_mode(DiffMode.FIRST)

        if args.filter:
            param.set_filter(True)
        if args.compact:
            param.set_compact(True)

        # load default diff from settings if not specified
        if not args.side and not args.down:
            geral = Settings().app
            diff_mode = geral.get_diff_mode()
            sidesize = int(geral.get_side_size())
            size_too_short = Report.get_terminal_size() < sidesize
            param.set_up_down(diff_mode == "down" or size_too_short)
        elif args.side:
            param.set_up_down(False)
        elif args.down:
            param.set_up_down(True)
        run = Run(args.target_list, args.cmd, param)
        run.execute()

    @staticmethod
    def run(args):
        PatternLoader.pattern = args.pattern
        param = Param.Basic().set_index(args.index)
        param.set_up_down(Settings().app.get_diff_mode() == "down")

        if args.filter:
            param.set_filter(True)
        run = Run(args.target_list, args.cmd, param)
        if args.now:
            run.set_autorun(True)
        run.set_curses()
        run.execute()

    @staticmethod
    def build(args):
        PatternLoader.pattern = args.pattern
        manip = Param.Manip().set_unlabel(args.unlabel).set_to_sort(args.sort).set_to_number(args.number)
        build = Build(args.target, args.target_list, manip, args.force)
        build.execute()

    @staticmethod
    def settings(args):
        settings = Settings()

        action = False

        if args.ascii:
            action = True
            settings.app.set_is_ascii(True)
            print("Encoding mode now is: ASCII")
        if args.unicode:
            action = True
            settings.app.set_is_ascii(False)
            print("Encoding mode now is: UNICODE")
        if args.mono:
            action = True
            settings.app.set_is_colored(False)
            print("Color mode now is: MONOCHROMATIC")
        if args.color:
            action = True
            settings.app.set_is_colored(True)
            print("Color mode now is: COLORED")
        if args.side:
            action = True
            settings.app.set_diff_mode("side")
            print("Diff mode now is: SIDE_BY_SIDE")
        if args.down:
            action = True
            settings.app.set_diff_mode("down")
            print("Diff mode now is: UP_DOWN")
        if args.lang:
            action = True
            settings.app.set_lang_def(args.lang)
            print("Default language extension now is:", args.lang)
        if args.ask:
            action = True
            settings.app.set_lang_def("")
            print("Language extension will be asked always.")

        if args.root:
            action = True
            path = os.path.abspath(args.root)
            settings.app.set_rootdir(path)
            print("Root directory now is: " + path)
        
        if args.editor:
            action = True
            settings.app.set_editor(args.editor)
            print(f"Novo comando para abrir arquivos de código: {args.editor}")

        if not action:
            action = True
            print(settings.get_settings_file())
            print("Diff mode: {}".format("DOWN" if settings.app.get_diff_mode() else "SIDE"))
            print("Encoding mode: {}".format("ASCII" if settings.app.is_ascii() else "UNICODE"))
            print("Color mode: {}".format("MONOCHROMATIC" if not settings.app.is_colored() else "COLORED"))
            value = settings.app.get_lang_def()
            print("Default language extension: {}".format("Always ask" if value == "" else value))

        settings.save_settings()

    @staticmethod
    def play(args):
        settings = Settings()
        if args.repo == "__ask":
            last = settings.app.get_last_rep()
            if last != "" and last in settings.reps:
                args.repo = last
            else:
                print("---------------------------------------")
                print("Escolha um dos repositórios para abrir:")
                for alias in settings.reps:
                    print(f"- {alias}")
                while True:
                    print("Digite o nome do repositório desejado: ", end="")
                    _rep_source = input()
                    if _rep_source in settings.reps:
                        args.repo = _rep_source
                        break
                    print("Repositorio não encontrado")
        
        print(f"Abrindo repositório de {args.repo}")
        settings.app.set_last_rep(args.repo)

        while True:
            rep_source: RepSource = settings.get_rep_source(args.repo)
            rep_data = settings.get_rep_data(args.repo)

            local = settings.app
            game = Game()
            file = rep_source.get_file(os.path.join(local.get_rootdir(), args.repo))
            game.parse_file(file)

            # passing a lambda function to the play class to save the settings
            ext = ""
            if args.graph:
                ext = ".svg" if args.svg else ".png"
            play = Play(app=local, game=game, rep_data=rep_data, rep_alias=args.repo)
            reload = play.play(ext)
            if not reload:
                break

    @staticmethod
    def down(args):
        Down.download_problem(args.course, args.activity, args.language, print)


class Parser:
    def __init__(self):
        self.parser: argparse.ArgumentParser = argparse.ArgumentParser(prog='tko', description=f'tko version {__version__}')
        self.subparsers = self.parser.add_subparsers(title='subcommands', help='help for subcommand.')

        self.parent_manip = self.create_parent_manip()
        self.parent_basic = self.create_parent_basic()

        self.add_parser_global()
        self.create_parent_basic()
        self.create_parent_manip()
        self.add_parser_run()
        self.add_parser_prun()
        self.add_parser_build()
        self.add_parser_down()
        self.add_parser_config()
        self.add_parser_repo()
        self.add_parser_play()

    def add_parser_global(self):
        self.parser.add_argument('-c', metavar='CONFIG_FILE', type=str, help='config json file.')
        self.parser.add_argument('-w', metavar='WIDTH', type=int, help="terminal width.")
        self.parser.add_argument('-v', action='store_true', help='show version.')
        self.parser.add_argument('-g', action='store_true', help='show tko simple guide.')
        self.parser.add_argument('-b', action='store_true', help='show bash simple guide.')
        self.parser.add_argument('-m', action='store_true', help='monochromatic.')
        self.parser.add_argument('-a', action='store_true', help='asc2 mode.')

    def create_parent_basic(self):
        parent_basic = argparse.ArgumentParser(add_help=False)
        parent_basic.add_argument('--index', '-i', metavar="I", type=int, help='run a specific index.')
        parent_basic.add_argument('--pattern', '-p', metavar="P", type=str, default='@.in @.sol',
                                  help='pattern load/save a folder, default: "@.in @.sol"')
        return parent_basic

    def create_parent_manip(self):
        parent_manip = argparse.ArgumentParser(add_help=False)
        parent_manip.add_argument('--width', '-w', type=int, help="term width.")
        parent_manip.add_argument('--unlabel', '-u', action='store_true', help='remove all labels.')
        parent_manip.add_argument('--number', '-n', action='store_true', help='number labels.')
        parent_manip.add_argument('--sort', '-s', action='store_true', help="sort test cases by input size.")
        parent_manip.add_argument('--pattern', '-p', metavar="@.in @.out", type=str, default='@.in @.sol',
                                  help='pattern load/save a folder, default: "@.in @.sol"')
        return parent_manip

    def add_parser_run(self):
        parser_r = self.subparsers.add_parser('run', parents=[self.parent_basic], help='run with test cases using curses.')
        parser_r.add_argument('target_list', metavar='T', type=str, nargs='*', help='solvers, test cases or folders.')
        parser_r.add_argument('--filter', '-f', action='store_true', help='filter solver in temp dir before run')
        parser_r.add_argument("--cmd", type=str, help="bash command to run code")
        parser_r.add_argument("--now", "-n", action='store_true', help="autorun skipping intro screen")
        parser_r.set_defaults(func=Main.run)

    def add_parser_prun(self):
        parser_r = self.subparsers.add_parser('go', parents=[self.parent_basic], help='run with test cases.')
        parser_r.add_argument('target_list', metavar='T', type=str, nargs='*', help='solvers, test cases or folders.')
        parser_r.add_argument('--filter', '-f', action='store_true', help='filter solver in temp dir before run')
        parser_r.add_argument('--compact', '-c', action='store_true', help='Do not show case descriptions in failures')
        parser_r.add_argument("--cmd", type=str, help="bash command to run code")

        group_n = parser_r.add_mutually_exclusive_group()
        group_n.add_argument('--quiet', '-q', action='store_true', help='quiet mode, do not show any failure.')
        group_n.add_argument('--all', '-a', action='store_true', help='show all failures.')

        # add an exclusive group for diff mode
        group = parser_r.add_mutually_exclusive_group()
        group.add_argument('--down', '-d', action='store_true', help="diff mode up-to-down.")
        group.add_argument('--side', '-s', action='store_true', help="diff mode side-by-side.")
        parser_r.set_defaults(func=Main.prun)

    def add_parser_build(self):
        parser_b = self.subparsers.add_parser('build', parents=[self.parent_manip], help='build a test target.')
        parser_b.add_argument('target', metavar='T_OUT', type=str, help='target to be build.')
        parser_b.add_argument('target_list', metavar='T', type=str, nargs='+', help='input test targets.')
        parser_b.add_argument('--force', '-f', action='store_true', help='enable overwrite.')
        parser_b.set_defaults(func=Main.build)

    def add_parser_down(self):
        parser_d = self.subparsers.add_parser('down', help='download problem from repository.')
        parser_d.add_argument('course', type=str, nargs='?', help=" [ fup | ed | poo ].")
        parser_d.add_argument('activity', type=str, nargs='?', help="activity @label.")
        parser_d.add_argument('--language', '-l', type=str, nargs='?', help="[ c | cpp | js | ts | py | java ]")
        parser_d.set_defaults(func=Main.down)

    def add_parser_config(self):
        parser_s = self.subparsers.add_parser('config', help='settings tool.')

        g_encoding = parser_s.add_mutually_exclusive_group()
        g_encoding.add_argument('--ascii', action='store_true',    help='set ascii mode.')
        g_encoding.add_argument('--unicode', action='store_true', help='set unicode mode.')

        g_color = parser_s.add_mutually_exclusive_group()
        g_color.add_argument('--color', action='store_true', help='set colored mode.')
        g_color.add_argument('--mono',  action='store_true', help='set mono    mode.')

        g_diff = parser_s.add_mutually_exclusive_group()
        g_diff.add_argument('--side', action='store_true', help='set side_by_side diff mode.')
        g_diff.add_argument('--down', action='store_true', help='set up_to_down   diff mode.')

        g_lang = parser_s.add_mutually_exclusive_group()
        g_lang.add_argument("--lang", '-l', metavar='ext', type=str, help="set default language extension.")
        g_lang.add_argument("--ask", action='store_true', help='ask language extension every time.')

        parser_s.add_argument("--root", metavar="path", type=str, help='set root directory.')
        parser_s.add_argument("--editor", metavar="cmd", type=str, help='set editor command.')

        parser_s.set_defaults(func=Main.settings)

    def add_parser_repo(self):
        parser_repo = self.subparsers.add_parser('rep', help='manipulate repositories.')
        subpar_repo = parser_repo.add_subparsers(title='subcommands', help='help for subcommand.')

        repo_list = subpar_repo.add_parser('list', help='list all repositories')
        repo_list.set_defaults(func=MRep.list)

        repo_add = subpar_repo.add_parser('add', help='add a repository.')
        repo_add.add_argument('alias', metavar='alias', type=str, help='alias of the repository to be added.')
        repo_add.add_argument('--url', '-u', type=str, help='add a repository url to the settings file.')
        repo_add.add_argument('--file', '-f', type=str, help='add a repository file to the settings file.')
        repo_add.set_defaults(func=MRep.add)

        repo_rm = subpar_repo.add_parser('rm', help='remove a repository.')
        repo_rm.add_argument('alias', metavar='alias', type=str, help='alias of the repository to be removed.')
        repo_rm.set_defaults(func=MRep.rm)

        repo_reset = subpar_repo.add_parser('reset', help='reset all repositories to factory default.')
        repo_reset.set_defaults(func=MRep.reset)

        repo_graph = subpar_repo.add_parser('graph', help='generate graph of the repository.')
        repo_graph.add_argument('alias', metavar='alias', type=str, help='alias of the repository to be graphed.')
        repo_graph.set_defaults(func=MRep.graph)

    def add_parser_play(self):
        parser_p = self.subparsers.add_parser('play', help='play a game.')
        parser_p.add_argument('repo', metavar='repo', type=str, nargs="?", default="__ask", help='repository to be played.')
        parser_p.add_argument("--graph", "-g", action='store_true', help='generate graph of the game using graphviz.')
        parser_p.add_argument("--svg", "-s", action='store_true', help='generate graph in svg instead png.')
        parser_p.set_defaults(func=Main.play)


def exec(parser: argparse.ArgumentParser, args):
    settings = Settings()
    if args.w is not None:
        Report.set_terminal_size(args.w)
    if args.c:
        settings.set_settings_file(args.c)
    settings.load_settings()
    settings.check_rootdir()
    if args.a or settings.app.is_ascii():
        symbols.set_ascii()
    else:
        symbols.set_unicode()
    if args.m:
        Color.enabled = False
    elif settings.app.is_colored():
        Color.enabled = True
        symbols.set_colors()

    if args.v or args.g or args.b:
        if args.v:
            print("tko version " + __version__)
        if args.b:
            print(bash_guide[1:], end="")
        if args.g:
            print(tko_guide[1:], end="")
    else:
        if "func" in args:
            args.func(args)
        else:
            parser.print_help()

def main():
    try:
        parser = Parser().parser
        args = parser.parse_args()
        exec(parser, args)
        sys.exit(0)
    except KeyboardInterrupt:
        print("\n\nKeyboard Interrupt")
        sys.exit(1)
    except Warning as w:
        print(w)
        sys.exit(1)
    # except Exception as e:
    #     print(e)
    #     sys.exit(1)


if __name__ == '__main__':
    main()
